{"ast":null,"code":"import _classCallCheck from \"C:/Users/sebas/Downloads/uft_plantilla_frontend/uft_plantilla_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/sebas/Downloads/uft_plantilla_frontend/uft_plantilla_frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport { Md5 } from './md5'; // Hashes any blob\n\nexport var Md5FileHasher = /*#__PURE__*/function () {\n  function Md5FileHasher(_callback) {\n    var _async = arguments.length > 1 && arguments[1] !== undefined ? arguments[1] : true;\n\n    var _partSize = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : 1048576;\n\n    _classCallCheck(this, Md5FileHasher);\n\n    this._callback = _callback;\n    this._async = _async;\n    this._partSize = _partSize;\n\n    this._configureReader();\n  }\n  /**\n   * Hash a blob of data in the worker\n   * @param blob Data to hash\n   */\n\n\n  _createClass(Md5FileHasher, [{\n    key: \"hash\",\n    value: function hash(blob) {\n      var self = this;\n      self._blob = blob; // self._length = Math.ceil(blob.size / self._partSize);\n\n      self._part = 0;\n      self._md5 = new Md5();\n\n      self._processPart();\n    }\n  }, {\n    key: \"_fail\",\n    value: function _fail() {\n      this._callback({\n        success: false,\n        result: 'data read failed'\n      });\n    }\n  }, {\n    key: \"_hashData\",\n    value: function _hashData(e) {\n      var self = this;\n\n      self._md5.appendByteArray(new Uint8Array(e.target.result));\n\n      if (self._part * self._partSize >= self._blob.size) {\n        self._callback({\n          success: true,\n          result: self._md5.end()\n        });\n      } else {\n        self._processPart();\n      }\n    }\n  }, {\n    key: \"_processPart\",\n    value: function _processPart() {\n      var self = this;\n      var endbyte = 0;\n      var current_part;\n      self._part += 1;\n\n      if (self._blob.size > self._partSize) {\n        // If blob bigger then part_size we will slice it up\n        endbyte = self._part * self._partSize;\n\n        if (endbyte > self._blob.size) {\n          endbyte = self._blob.size;\n        }\n\n        current_part = self._blob.slice((self._part - 1) * self._partSize, endbyte);\n      } else {\n        current_part = self._blob;\n      }\n\n      if (self._async) {\n        self._reader.readAsArrayBuffer(current_part);\n      } else {\n        setTimeout(function () {\n          try {\n            self._hashData({\n              target: {\n                result: self._reader.readAsArrayBuffer(current_part)\n              }\n            });\n          } catch (e) {\n            self._fail();\n          }\n        }, 0);\n      }\n    }\n  }, {\n    key: \"_configureReader\",\n    value: function _configureReader() {\n      var self = this;\n\n      if (self._async) {\n        self._reader = new FileReader();\n        self._reader.onload = self._hashData.bind(self);\n        self._reader.onerror = self._fail.bind(self);\n        self._reader.onabort = self._fail.bind(self);\n      } else {\n        self._reader = new FileReaderSync();\n      }\n    }\n  }]);\n\n  return Md5FileHasher;\n}();","map":{"version":3,"sources":["../../src/md5_file_hasher.ts"],"names":[],"mappings":";;AAAA,SAAQ,GAAR,QAAkB,OAAlB,C,CASA;;AACA,WAAa,aAAb;AASI,yBACY,SADZ,EAGuC;AAAA,QAD3B,MAC2B,uEADT,IACS;;AAAA,QAA3B,SAA2B,uEAAP,OAAO;;AAAA;;AAF3B,SAAA,SAAA,GAAA,SAAA;AACA,SAAA,MAAA,GAAA,MAAA;AACA,SAAA,SAAA,GAAA,SAAA;;AAER,SAAK,gBAAL;AACH;AAED;;;;;;AAjBJ;AAAA;AAAA,WAqBW,cAAK,IAAL,EAAc;AACjB,UAAM,IAAI,GAAG,IAAb;AAEA,MAAA,IAAI,CAAC,KAAL,GAAa,IAAb,CAHiB,CAIjB;;AACA,MAAA,IAAI,CAAC,KAAL,GAAa,CAAb;AACA,MAAA,IAAI,CAAC,IAAL,GAAY,IAAI,GAAJ,EAAZ;;AACA,MAAA,IAAI,CAAC,YAAL;AACH;AA7BL;AAAA;AAAA,WAgCY,iBAAK;AACT,WAAK,SAAL,CAAe;AACX,QAAA,OAAO,EAAE,KADE;AAEX,QAAA,MAAM,EAAE;AAFG,OAAf;AAIH;AArCL;AAAA;AAAA,WAuCY,mBAAU,CAAV,EAAgB;AACpB,UAAI,IAAI,GAAG,IAAX;;AAEA,MAAA,IAAI,CAAC,IAAL,CAAU,eAAV,CAA0B,IAAI,UAAJ,CAAe,CAAC,CAAC,MAAF,CAAS,MAAxB,CAA1B;;AACA,UAAI,IAAI,CAAC,KAAL,GAAa,IAAI,CAAC,SAAlB,IAA+B,IAAI,CAAC,KAAL,CAAW,IAA9C,EAAoD;AAChD,QAAA,IAAI,CAAC,SAAL,CAAe;AACX,UAAA,OAAO,EAAE,IADE;AAEX,UAAA,MAAM,EAAE,IAAI,CAAC,IAAL,CAAU,GAAV;AAFG,SAAf;AAIH,OALD,MAKO;AACH,QAAA,IAAI,CAAC,YAAL;AACH;AACJ;AAnDL;AAAA;AAAA,WAqDY,wBAAY;AAChB,UAAM,IAAI,GAAG,IAAb;AACA,UAAI,OAAO,GAAG,CAAd;AACA,UAAI,YAAJ;AAEA,MAAA,IAAI,CAAC,KAAL,IAAc,CAAd;;AAEA,UAAI,IAAI,CAAC,KAAL,CAAW,IAAX,GAAkB,IAAI,CAAC,SAA3B,EAAsC;AAAS;AAC3C,QAAA,OAAO,GAAG,IAAI,CAAC,KAAL,GAAa,IAAI,CAAC,SAA5B;;AACA,YAAI,OAAO,GAAG,IAAI,CAAC,KAAL,CAAW,IAAzB,EAA+B;AAC3B,UAAA,OAAO,GAAG,IAAI,CAAC,KAAL,CAAW,IAArB;AACH;;AACD,QAAA,YAAY,GAAG,IAAI,CAAC,KAAL,CAAW,KAAX,CAAiB,CAAC,IAAI,CAAC,KAAL,GAAa,CAAd,IAAmB,IAAI,CAAC,SAAzC,EAAoD,OAApD,CAAf;AACH,OAND,MAMO;AACH,QAAA,YAAY,GAAG,IAAI,CAAC,KAApB;AACH;;AAED,UAAI,IAAI,CAAC,MAAT,EAAiB;AACb,QAAA,IAAI,CAAC,OAAL,CAAa,iBAAb,CAA+B,YAA/B;AACH,OAFD,MAEO;AACH,QAAA,UAAU,CAAC,YAAK;AACZ,cAAI;AACA,YAAA,IAAI,CAAC,SAAL,CAAe;AACX,cAAA,MAAM,EAAE;AACJ,gBAAA,MAAM,EAAE,IAAI,CAAC,OAAL,CAAa,iBAAb,CAA+B,YAA/B;AADJ;AADG,aAAf;AAKH,WAND,CAME,OAAO,CAAP,EAAU;AACR,YAAA,IAAI,CAAC,KAAL;AACH;AACJ,SAVS,EAUP,CAVO,CAAV;AAWH;AACJ;AArFL;AAAA;AAAA,WAuFY,4BAAgB;AACpB,UAAM,IAAI,GAAG,IAAb;;AAEA,UAAI,IAAI,CAAC,MAAT,EAAiB;AACb,QAAA,IAAI,CAAC,OAAL,GAAe,IAAI,UAAJ,EAAf;AACA,QAAA,IAAI,CAAC,OAAL,CAAa,MAAb,GAAsB,IAAI,CAAC,SAAL,CAAe,IAAf,CAAoB,IAApB,CAAtB;AACA,QAAA,IAAI,CAAC,OAAL,CAAa,OAAb,GAAuB,IAAI,CAAC,KAAL,CAAW,IAAX,CAAgB,IAAhB,CAAvB;AACA,QAAA,IAAI,CAAC,OAAL,CAAa,OAAb,GAAuB,IAAI,CAAC,KAAL,CAAW,IAAX,CAAgB,IAAhB,CAAvB;AACH,OALD,MAKO;AACH,QAAA,IAAI,CAAC,OAAL,GAAe,IAAI,cAAJ,EAAf;AACH;AACJ;AAlGL;;AAAA;AAAA","sourceRoot":"","sourcesContent":["import { Md5 } from './md5';\n// Hashes any blob\nexport class Md5FileHasher {\n    constructor(_callback, // Callback to return the result\n    _async = true, // Async version is not always available in a web worker\n    _partSize = 1048576) {\n        this._callback = _callback;\n        this._async = _async;\n        this._partSize = _partSize;\n        this._configureReader();\n    }\n    /**\n     * Hash a blob of data in the worker\n     * @param blob Data to hash\n     */\n    hash(blob) {\n        const self = this;\n        self._blob = blob;\n        // self._length = Math.ceil(blob.size / self._partSize);\n        self._part = 0;\n        self._md5 = new Md5();\n        self._processPart();\n    }\n    _fail() {\n        this._callback({\n            success: false,\n            result: 'data read failed'\n        });\n    }\n    _hashData(e) {\n        let self = this;\n        self._md5.appendByteArray(new Uint8Array(e.target.result));\n        if (self._part * self._partSize >= self._blob.size) {\n            self._callback({\n                success: true,\n                result: self._md5.end()\n            });\n        }\n        else {\n            self._processPart();\n        }\n    }\n    _processPart() {\n        const self = this;\n        let endbyte = 0;\n        let current_part;\n        self._part += 1;\n        if (self._blob.size > self._partSize) { // If blob bigger then part_size we will slice it up\n            endbyte = self._part * self._partSize;\n            if (endbyte > self._blob.size) {\n                endbyte = self._blob.size;\n            }\n            current_part = self._blob.slice((self._part - 1) * self._partSize, endbyte);\n        }\n        else {\n            current_part = self._blob;\n        }\n        if (self._async) {\n            self._reader.readAsArrayBuffer(current_part);\n        }\n        else {\n            setTimeout(() => {\n                try {\n                    self._hashData({\n                        target: {\n                            result: self._reader.readAsArrayBuffer(current_part)\n                        },\n                    });\n                }\n                catch (e) {\n                    self._fail();\n                }\n            }, 0);\n        }\n    }\n    _configureReader() {\n        const self = this;\n        if (self._async) {\n            self._reader = new FileReader();\n            self._reader.onload = self._hashData.bind(self);\n            self._reader.onerror = self._fail.bind(self);\n            self._reader.onabort = self._fail.bind(self);\n        }\n        else {\n            self._reader = new FileReaderSync();\n        }\n    }\n}\n//# sourceMappingURL=md5_file_hasher.js.map"]},"metadata":{},"sourceType":"module"}