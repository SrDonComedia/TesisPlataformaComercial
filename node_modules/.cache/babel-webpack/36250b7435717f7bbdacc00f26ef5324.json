{"ast":null,"code":"import _classCallCheck from \"C:/Users/sebas/Downloads/uft_plantilla_frontend/uft_plantilla_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport _createClass from \"C:/Users/sebas/Downloads/uft_plantilla_frontend/uft_plantilla_frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\n;\nexport var ParallelHasher = /*#__PURE__*/function () {\n  function ParallelHasher(workerUri, workerOptions) {\n    _classCallCheck(this, ParallelHasher);\n\n    this._queue = [];\n    this._ready = true;\n    var self = this;\n\n    if (Worker) {\n      self._hashWorker = new Worker(workerUri, workerOptions);\n      self._hashWorker.onmessage = self._recievedMessage.bind(self);\n\n      self._hashWorker.onerror = function (err) {\n        self._ready = false;\n        console.error('Hash worker failure', err);\n      };\n    } else {\n      self._ready = false;\n      console.error('Web Workers are not supported in this browser');\n    }\n  }\n  /**\n   * Hash a blob of data in the worker\n   * @param blob Data to hash\n   * @returns Promise of the Hashed result\n   */\n\n\n  _createClass(ParallelHasher, [{\n    key: \"hash\",\n    value: function hash(blob) {\n      var self = this;\n      var promise;\n      promise = new Promise(function (resolve, reject) {\n        self._queue.push({\n          blob: blob,\n          resolve: resolve,\n          reject: reject\n        });\n\n        self._processNext();\n      });\n      return promise;\n    }\n    /** Terminate any existing hash requests */\n\n  }, {\n    key: \"terminate\",\n    value: function terminate() {\n      this._ready = false;\n\n      this._hashWorker.terminate();\n    } // Processes the next item in the queue\n\n  }, {\n    key: \"_processNext\",\n    value: function _processNext() {\n      if (this._ready && !this._processing && this._queue.length > 0) {\n        this._processing = this._queue.pop();\n\n        this._hashWorker.postMessage(this._processing.blob);\n      }\n    } // Hash result is returned from the worker\n\n  }, {\n    key: \"_recievedMessage\",\n    value: function _recievedMessage(evt) {\n      var _a, _b;\n\n      var data = evt.data;\n\n      if (data.success) {\n        (_a = this._processing) === null || _a === void 0 ? void 0 : _a.resolve(data.result);\n      } else {\n        (_b = this._processing) === null || _b === void 0 ? void 0 : _b.reject(data.result);\n      }\n\n      this._processing = undefined;\n\n      this._processNext();\n    }\n  }]);\n\n  return ParallelHasher;\n}();","map":{"version":3,"sources":["../../src/parallel_hasher.ts"],"names":[],"mappings":";;AAeC;AAED,WAAa,cAAb;AAOI,0BAAY,SAAZ,EAA+B,aAA/B,EAA4D;AAAA;;AANpD,SAAA,MAAA,GAA2B,EAA3B;AAIA,SAAA,MAAA,GAAkB,IAAlB;AAGJ,QAAM,IAAI,GAAG,IAAb;;AAEA,QAAI,MAAJ,EAAY;AACR,MAAA,IAAI,CAAC,WAAL,GAAmB,IAAI,MAAJ,CAAW,SAAX,EAAsB,aAAtB,CAAnB;AACA,MAAA,IAAI,CAAC,WAAL,CAAiB,SAAjB,GAA6B,IAAI,CAAC,gBAAL,CAAsB,IAAtB,CAA2B,IAA3B,CAA7B;;AACA,MAAA,IAAI,CAAC,WAAL,CAAiB,OAAjB,GAA2B,UAAC,GAAD,EAAa;AACpC,QAAA,IAAI,CAAC,MAAL,GAAc,KAAd;AACA,QAAA,OAAO,CAAC,KAAR,CAAc,qBAAd,EAAqC,GAArC;AACH,OAHD;AAIH,KAPD,MAOO;AACH,MAAA,IAAI,CAAC,MAAL,GAAc,KAAd;AACA,MAAA,OAAO,CAAC,KAAR,CAAc,+CAAd;AACH;AACJ;AAED;;;;;;;AAvBJ;AAAA;AAAA,WA4BW,cAAK,IAAL,EAAc;AACjB,UAAM,IAAI,GAAG,IAAb;AACA,UAAI,OAAJ;AAEA,MAAA,OAAO,GAAG,IAAI,OAAJ,CAAY,UAAC,OAAD,EAAU,MAAV,EAAoB;AACtC,QAAA,IAAI,CAAC,MAAL,CAAY,IAAZ,CAAiB;AACb,UAAA,IAAI,EAAJ,IADa;AAEb,UAAA,OAAO,EAAP,OAFa;AAGb,UAAA,MAAM,EAAN;AAHa,SAAjB;;AAMA,QAAA,IAAI,CAAC,YAAL;AACH,OARS,CAAV;AAUA,aAAO,OAAP;AACH;AAED;;AA7CJ;AAAA;AAAA,WA8CW,qBAAS;AACZ,WAAK,MAAL,GAAc,KAAd;;AACA,WAAK,WAAL,CAAiB,SAAjB;AACH,KAjDL,CAmDI;;AAnDJ;AAAA;AAAA,WAoDY,wBAAY;AAChB,UAAI,KAAK,MAAL,IAAe,CAAC,KAAK,WAArB,IAAoC,KAAK,MAAL,CAAY,MAAZ,GAAqB,CAA7D,EAAgE;AAC5D,aAAK,WAAL,GAAmB,KAAK,MAAL,CAAY,GAAZ,EAAnB;;AACA,aAAK,WAAL,CAAiB,WAAjB,CAA6B,KAAK,WAAL,CAAkB,IAA/C;AACH;AACJ,KAzDL,CA2DI;;AA3DJ;AAAA;AAAA,WA4DY,0BAAiB,GAAjB,EAAyB;;;AAC7B,UAAM,IAAI,GAAG,GAAG,CAAC,IAAjB;;AAEA,UAAI,IAAI,CAAC,OAAT,EAAkB;AACd,SAAA,EAAA,GAAA,KAAK,WAAL,MAAgB,IAAhB,IAAgB,EAAA,KAAA,KAAA,CAAhB,GAAgB,KAAA,CAAhB,GAAgB,EAAA,CAAE,OAAF,CAAU,IAAI,CAAC,MAAf,CAAhB;AACH,OAFD,MAEO;AACH,SAAA,EAAA,GAAA,KAAK,WAAL,MAAgB,IAAhB,IAAgB,EAAA,KAAA,KAAA,CAAhB,GAAgB,KAAA,CAAhB,GAAgB,EAAA,CAAE,MAAF,CAAS,IAAI,CAAC,MAAd,CAAhB;AACH;;AAED,WAAK,WAAL,GAAmB,SAAnB;;AACA,WAAK,YAAL;AACH;AAvEL;;AAAA;AAAA","sourceRoot":"","sourcesContent":[";\nexport class ParallelHasher {\n    constructor(workerUri, workerOptions) {\n        this._queue = [];\n        this._ready = true;\n        const self = this;\n        if (Worker) {\n            self._hashWorker = new Worker(workerUri, workerOptions);\n            self._hashWorker.onmessage = self._recievedMessage.bind(self);\n            self._hashWorker.onerror = (err) => {\n                self._ready = false;\n                console.error('Hash worker failure', err);\n            };\n        }\n        else {\n            self._ready = false;\n            console.error('Web Workers are not supported in this browser');\n        }\n    }\n    /**\n     * Hash a blob of data in the worker\n     * @param blob Data to hash\n     * @returns Promise of the Hashed result\n     */\n    hash(blob) {\n        const self = this;\n        let promise;\n        promise = new Promise((resolve, reject) => {\n            self._queue.push({\n                blob,\n                resolve,\n                reject,\n            });\n            self._processNext();\n        });\n        return promise;\n    }\n    /** Terminate any existing hash requests */\n    terminate() {\n        this._ready = false;\n        this._hashWorker.terminate();\n    }\n    // Processes the next item in the queue\n    _processNext() {\n        if (this._ready && !this._processing && this._queue.length > 0) {\n            this._processing = this._queue.pop();\n            this._hashWorker.postMessage(this._processing.blob);\n        }\n    }\n    // Hash result is returned from the worker\n    _recievedMessage(evt) {\n        var _a, _b;\n        const data = evt.data;\n        if (data.success) {\n            (_a = this._processing) === null || _a === void 0 ? void 0 : _a.resolve(data.result);\n        }\n        else {\n            (_b = this._processing) === null || _b === void 0 ? void 0 : _b.reject(data.result);\n        }\n        this._processing = undefined;\n        this._processNext();\n    }\n}\n//# sourceMappingURL=parallel_hasher.js.map"]},"metadata":{},"sourceType":"module"}