{"ast":null,"code":"import _toConsumableArray from \"C:/Users/sebas/Downloads/uft_plantilla_frontend/uft_plantilla_frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _inherits from \"C:/Users/sebas/Downloads/uft_plantilla_frontend/uft_plantilla_frontend/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/Users/sebas/Downloads/uft_plantilla_frontend/uft_plantilla_frontend/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _createClass from \"C:/Users/sebas/Downloads/uft_plantilla_frontend/uft_plantilla_frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"C:/Users/sebas/Downloads/uft_plantilla_frontend/uft_plantilla_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { Injectable, InjectionToken, Optional, Inject, EventEmitter, Component, Input, Output, NgModule } from '@angular/core';\nimport { CommonModule } from '@angular/common';\nimport { Md5 } from 'ts-md5';\nimport { HttpClient } from '@angular/common/http';\nimport { takeWhile, map } from 'rxjs/operators';\n/**\n * Contract of all async sources.\n * Every async source must implement the processResponse method that extracts the avatar url from the data\n */\n\nvar AsyncSource = /*#__PURE__*/_createClass(function AsyncSource(sourceId) {\n  _classCallCheck(this, AsyncSource);\n\n  this.sourceId = sourceId;\n});\n\nvar AvatarSource;\n\n(function (AvatarSource) {\n  AvatarSource[\"FACEBOOK\"] = \"facebook\";\n  AvatarSource[\"GOOGLE\"] = \"google\";\n  AvatarSource[\"TWITTER\"] = \"twitter\";\n  AvatarSource[\"INSTAGRAM\"] = \"instagram\";\n  AvatarSource[\"VKONTAKTE\"] = \"vkontakte\";\n  AvatarSource[\"SKYPE\"] = \"skype\";\n  AvatarSource[\"GRAVATAR\"] = \"gravatar\";\n  AvatarSource[\"GITHUB\"] = \"github\";\n  AvatarSource[\"CUSTOM\"] = \"custom\";\n  AvatarSource[\"INITIALS\"] = \"initials\";\n  AvatarSource[\"VALUE\"] = \"value\";\n})(AvatarSource || (AvatarSource = {}));\n/**\n *  Facebook source implementation.\n *  Fetch avatar source based on facebook identifier\n *  and image size\n */\n\n\nvar Facebook = /*#__PURE__*/function () {\n  function Facebook(sourceId) {\n    _classCallCheck(this, Facebook);\n\n    this.sourceId = sourceId;\n    this.sourceType = AvatarSource.FACEBOOK;\n  }\n\n  _createClass(Facebook, [{\n    key: \"getAvatar\",\n    value: function getAvatar(size) {\n      return 'https://graph.facebook.com/' + \"\".concat(this.sourceId, \"/picture?width=\").concat(size, \"&height=\").concat(size);\n    }\n  }]);\n\n  return Facebook;\n}();\n/**\n *  Twitter source implementation.\n *  Fetch avatar source based on google identifier\n *  and image size\n */\n\n\nvar Twitter = /*#__PURE__*/function () {\n  function Twitter(sourceId) {\n    _classCallCheck(this, Twitter);\n\n    this.sourceId = sourceId;\n    this.sourceType = AvatarSource.TWITTER;\n  }\n\n  _createClass(Twitter, [{\n    key: \"getAvatar\",\n    value: function getAvatar(size) {\n      var twitterImgSize = this.getImageSize(size);\n      return \"https://twitter.com/\".concat(this.sourceId, \"/profile_image?size=\").concat(twitterImgSize);\n    }\n  }, {\n    key: \"getImageSize\",\n    value: function getImageSize(size) {\n      if (size <= 24) {\n        return 'mini';\n      }\n\n      if (size <= 48) {\n        return 'normal';\n      }\n\n      if (size <= 73) {\n        return 'bigger';\n      }\n\n      return 'original';\n    }\n  }]);\n\n  return Twitter;\n}();\n/**\n *  Google source implementation.\n *  Fetch avatar source based on google identifier\n *  and image size\n */\n\n\nvar Google = /*#__PURE__*/function (_AsyncSource) {\n  _inherits(Google, _AsyncSource);\n\n  var _super = _createSuper(Google);\n\n  function Google(sourceId) {\n    var _this;\n\n    _classCallCheck(this, Google);\n\n    _this = _super.call(this, sourceId);\n    _this.sourceType = AvatarSource.GOOGLE;\n    return _this;\n  }\n\n  _createClass(Google, [{\n    key: \"getAvatar\",\n    value: function getAvatar() {\n      return \"https://picasaweb.google.com/data/entry/api/user/\".concat(this.sourceId, \"?alt=json\");\n    }\n    /**\n     * Extract google avatar from json data\n     */\n\n  }, {\n    key: \"processResponse\",\n    value: function processResponse(data, size) {\n      var avatarSrc = data.entry.gphoto$thumbnail.$t;\n\n      if (avatarSrc) {\n        return avatarSrc.replace('s64', 's' + size);\n      }\n\n      return null;\n    }\n  }]);\n\n  return Google;\n}(AsyncSource);\n/**\n *  Instagram source impelementation.\n *  Fetch avatar source based on instagram identifier\n */\n\n\nvar Instagram = /*#__PURE__*/function (_AsyncSource2) {\n  _inherits(Instagram, _AsyncSource2);\n\n  var _super2 = _createSuper(Instagram);\n\n  function Instagram(sourceId) {\n    var _this2;\n\n    _classCallCheck(this, Instagram);\n\n    _this2 = _super2.call(this, sourceId);\n    _this2.sourceType = AvatarSource.INSTAGRAM;\n    return _this2;\n  }\n\n  _createClass(Instagram, [{\n    key: \"getAvatar\",\n    value: function getAvatar() {\n      return \"https://www.instagram.com/\".concat(this.sourceId, \"/?__a=1\");\n    }\n    /**\n     * extract instagram avatar from json data\n     */\n\n  }, {\n    key: \"processResponse\",\n    value: function processResponse(data, size) {\n      return \"\".concat(data.graphql.user.profile_pic_url_hd, \"&s=\").concat(size);\n    }\n  }]);\n\n  return Instagram;\n}(AsyncSource);\n/**\n *  Custom source implementation.\n *  return custom image as an avatar\n *\n */\n\n\nvar Custom = /*#__PURE__*/function () {\n  function Custom(sourceId) {\n    _classCallCheck(this, Custom);\n\n    this.sourceId = sourceId;\n    this.sourceType = AvatarSource.CUSTOM;\n  }\n\n  _createClass(Custom, [{\n    key: \"getAvatar\",\n    value: function getAvatar() {\n      return this.sourceId;\n    }\n  }]);\n\n  return Custom;\n}();\n/**\n * Initials source implementation.\n * return the initials of the given value\n */\n\n\nvar Initials = /*#__PURE__*/function () {\n  function Initials(sourceId) {\n    _classCallCheck(this, Initials);\n\n    this.sourceId = sourceId;\n    this.sourceType = AvatarSource.INITIALS;\n  }\n\n  _createClass(Initials, [{\n    key: \"getAvatar\",\n    value: function getAvatar(size) {\n      return this.getInitials(this.sourceId, size);\n    }\n    /**\n     * Returns the initial letters of a name in a string.\n     */\n\n  }, {\n    key: \"getInitials\",\n    value: function getInitials(name, size) {\n      name = name.trim();\n\n      if (!name) {\n        return '';\n      }\n\n      var initials = name.split(' ');\n\n      if (size && size < initials.length) {\n        return this.constructInitials(initials.slice(0, size));\n      } else {\n        return this.constructInitials(initials);\n      }\n    }\n    /**\n     * Iterates a person's name string to get the initials of each word in uppercase.\n     */\n\n  }, {\n    key: \"constructInitials\",\n    value: function constructInitials(elements) {\n      if (!elements || !elements.length) {\n        return '';\n      }\n\n      return elements.filter(function (element) {\n        return element && element.length > 0;\n      }).map(function (element) {\n        return element[0].toUpperCase();\n      }).join('');\n    }\n  }]);\n\n  return Initials;\n}();\n\nfunction isRetina() {\n  if (typeof window !== 'undefined' && window !== null) {\n    if (window.devicePixelRatio > 1.25) {\n      return true;\n    }\n\n    var mediaQuery = '(-webkit-min-device-pixel-ratio: 1.25), (min--moz-device-pixel-ratio: 1.25), (-o-min-device-pixel-ratio: 5/4), (min-resolution: 1.25dppx)';\n\n    if (window.matchMedia && window.matchMedia(mediaQuery).matches) {\n      return true;\n    }\n  }\n\n  return false;\n}\n/**\n *  Gravatar source implementation.\n *  Fetch avatar source based on gravatar email\n */\n\n\nvar Gravatar = /*#__PURE__*/function () {\n  function Gravatar(value) {\n    _classCallCheck(this, Gravatar);\n\n    this.value = value;\n    this.sourceType = AvatarSource.GRAVATAR;\n    this.sourceId = value.match('^[a-f0-9]{32}$') ? value : Md5.hashStr(value).toString();\n  }\n\n  _createClass(Gravatar, [{\n    key: \"getAvatar\",\n    value: function getAvatar(size) {\n      var avatarSize = isRetina() ? size * 2 : size;\n      return \"https://secure.gravatar.com/avatar/\".concat(this.sourceId, \"?s=\").concat(avatarSize, \"&d=404\");\n    }\n  }]);\n\n  return Gravatar;\n}();\n/**\n *  Skype source implementation.\n *  Fetch avatar source based on skype identifier\n */\n\n\nvar Skype = /*#__PURE__*/function () {\n  function Skype(sourceId) {\n    _classCallCheck(this, Skype);\n\n    this.sourceId = sourceId;\n    this.sourceType = AvatarSource.SKYPE;\n  }\n\n  _createClass(Skype, [{\n    key: \"getAvatar\",\n    value: function getAvatar() {\n      return \"https://api.skype.com/users/\".concat(this.sourceId, \"/profile/avatar\");\n    }\n  }]);\n\n  return Skype;\n}();\n/**\n *  Value source implementation.\n *  return the value as avatar\n */\n\n\nvar Value = /*#__PURE__*/function () {\n  function Value(sourceId) {\n    _classCallCheck(this, Value);\n\n    this.sourceId = sourceId;\n    this.sourceType = AvatarSource.VALUE;\n  }\n\n  _createClass(Value, [{\n    key: \"getAvatar\",\n    value: function getAvatar() {\n      return this.sourceId;\n    }\n  }]);\n\n  return Value;\n}();\n/**\n *  Vkontakte source implementation.\n *  Fetch avatar source based on vkontakte identifier\n *  and image size\n */\n\n\nvar apiVersion = 5.8;\n\nvar Vkontakte = /*#__PURE__*/function (_AsyncSource3) {\n  _inherits(Vkontakte, _AsyncSource3);\n\n  var _super3 = _createSuper(Vkontakte);\n\n  function Vkontakte(sourceId) {\n    var _this3;\n\n    _classCallCheck(this, Vkontakte);\n\n    _this3 = _super3.call(this, sourceId);\n    _this3.sourceType = AvatarSource.VKONTAKTE;\n    return _this3;\n  }\n\n  _createClass(Vkontakte, [{\n    key: \"getAvatar\",\n    value: function getAvatar(size) {\n      var imgSize = this.getImageSize(size);\n      return \"https://api.vk.com/method/users.get?user_id=\".concat(this.sourceId, \"&v=\").concat(apiVersion, \"&fields=\").concat(imgSize);\n    }\n    /**\n     * extract vkontakte avatar from json data\n     */\n\n  }, {\n    key: \"processResponse\",\n    value: function processResponse(data) {\n      // avatar key property is the size used to generate avatar url\n      // size property is always the last key in the response object\n      var sizeProperty = Object.keys(data['response'][0]).pop();\n\n      if (!sizeProperty) {\n        return null;\n      } // return avatar src\n\n\n      return data['response'][0][sizeProperty] || null;\n    }\n    /**\n     * Returns image size related to vkontakte API\n     */\n\n  }, {\n    key: \"getImageSize\",\n    value: function getImageSize(size) {\n      if (size <= 50) {\n        return 'photo_50';\n      }\n\n      if (size <= 100) {\n        return 'photo_100';\n      }\n\n      if (size <= 200) {\n        return 'photo_200';\n      }\n\n      return 'photo_max';\n    }\n  }]);\n\n  return Vkontakte;\n}(AsyncSource);\n/**\n *  GitHub source implementation.\n *  Fetch avatar source based on github identifier\n */\n\n\nvar Github = /*#__PURE__*/function (_AsyncSource4) {\n  _inherits(Github, _AsyncSource4);\n\n  var _super4 = _createSuper(Github);\n\n  function Github(sourceId) {\n    var _this4;\n\n    _classCallCheck(this, Github);\n\n    _this4 = _super4.call(this, sourceId);\n    _this4.sourceType = AvatarSource.GITHUB;\n    return _this4;\n  }\n\n  _createClass(Github, [{\n    key: \"getAvatar\",\n    value: function getAvatar() {\n      return \"https://api.github.com/users/\".concat(this.sourceId);\n    }\n    /**\n     * extract github avatar from json data\n     */\n\n  }, {\n    key: \"processResponse\",\n    value: function processResponse(data, size) {\n      if (size) {\n        return \"\".concat(data.avatar_url, \"&s=\").concat(size);\n      }\n\n      return data.avatar_url;\n    }\n  }]);\n\n  return Github;\n}(AsyncSource);\n/**\n * Factory class that implements factory method pattern.\n * Used to create Source implementation class based\n * on the source Type\n */\n\n\nvar SourceFactory = /*#__PURE__*/function () {\n  function SourceFactory() {\n    _classCallCheck(this, SourceFactory);\n\n    this.sources = {};\n    this.sources[AvatarSource.FACEBOOK] = Facebook;\n    this.sources[AvatarSource.TWITTER] = Twitter;\n    this.sources[AvatarSource.GOOGLE] = Google;\n    this.sources[AvatarSource.INSTAGRAM] = Instagram;\n    this.sources[AvatarSource.SKYPE] = Skype;\n    this.sources[AvatarSource.GRAVATAR] = Gravatar;\n    this.sources[AvatarSource.CUSTOM] = Custom;\n    this.sources[AvatarSource.INITIALS] = Initials;\n    this.sources[AvatarSource.VALUE] = Value;\n    this.sources[AvatarSource.VKONTAKTE] = Vkontakte;\n    this.sources[AvatarSource.GITHUB] = Github;\n  }\n\n  _createClass(SourceFactory, [{\n    key: \"newInstance\",\n    value: function newInstance(sourceType, sourceValue) {\n      return new this.sources[sourceType](sourceValue);\n    }\n  }]);\n\n  return SourceFactory;\n}();\n\nSourceFactory.decorators = [{\n  type: Injectable\n}];\n\nSourceFactory.ctorParameters = function () {\n  return [];\n};\n/**\n * Token used to inject the AvatarConfig object\n */\n\n\nvar AVATAR_CONFIG = new InjectionToken('avatar.config');\n\nvar AvatarConfigService = /*#__PURE__*/function () {\n  function AvatarConfigService(userConfig) {\n    _classCallCheck(this, AvatarConfigService);\n\n    this.userConfig = userConfig;\n  }\n\n  _createClass(AvatarConfigService, [{\n    key: \"getAvatarSources\",\n    value: function getAvatarSources(defaultSources) {\n      if (this.userConfig && this.userConfig.sourcePriorityOrder && this.userConfig.sourcePriorityOrder.length) {\n        var uniqueSources = _toConsumableArray(new Set(this.userConfig.sourcePriorityOrder));\n\n        var validSources = uniqueSources.filter(function (source) {\n          return defaultSources.includes(source);\n        });\n        return [].concat(_toConsumableArray(validSources), _toConsumableArray(defaultSources.filter(function (source) {\n          return !validSources.includes(source);\n        })));\n      }\n\n      return defaultSources;\n    }\n  }, {\n    key: \"getAvatarColors\",\n    value: function getAvatarColors(defaultColors) {\n      return this.userConfig && this.userConfig.colors && this.userConfig.colors.length && this.userConfig.colors || defaultColors;\n    }\n  }]);\n\n  return AvatarConfigService;\n}();\n\nAvatarConfigService.decorators = [{\n  type: Injectable\n}];\n\nAvatarConfigService.ctorParameters = function () {\n  return [{\n    type: undefined,\n    decorators: [{\n      type: Optional\n    }, {\n      type: Inject,\n      args: [AVATAR_CONFIG]\n    }]\n  }];\n};\n/**\n * list of Supported avatar sources\n */\n\n\nvar defaultSources = [AvatarSource.FACEBOOK, AvatarSource.GOOGLE, AvatarSource.TWITTER, AvatarSource.INSTAGRAM, AvatarSource.VKONTAKTE, AvatarSource.SKYPE, AvatarSource.GRAVATAR, AvatarSource.GITHUB, AvatarSource.CUSTOM, AvatarSource.INITIALS, AvatarSource.VALUE];\n/**\n * list of default colors\n */\n\nvar defaultColors = ['#1abc9c', '#3498db', '#f1c40f', '#8e44ad', '#e74c3c', '#d35400', '#2c3e50', '#7f8c8d'];\n/**\n * Provides utilities methods related to Avatar component\n */\n\nvar AvatarService = /*#__PURE__*/function () {\n  function AvatarService(http, avatarConfigService) {\n    _classCallCheck(this, AvatarService);\n\n    this.http = http;\n    this.avatarConfigService = avatarConfigService;\n    this.avatarSources = defaultSources;\n    this.avatarColors = defaultColors;\n    this.failedSources = new Map();\n    this.overrideAvatarSources();\n    this.overrideAvatarColors();\n  }\n\n  _createClass(AvatarService, [{\n    key: \"fetchAvatar\",\n    value: function fetchAvatar(avatarUrl) {\n      return this.http.get(avatarUrl);\n    }\n  }, {\n    key: \"getRandomColor\",\n    value: function getRandomColor(avatarText) {\n      if (!avatarText) {\n        return 'transparent';\n      }\n\n      var asciiCodeSum = this.calculateAsciiCode(avatarText);\n      return this.avatarColors[asciiCodeSum % this.avatarColors.length];\n    }\n  }, {\n    key: \"compareSources\",\n    value: function compareSources(sourceType1, sourceType2) {\n      return this.getSourcePriority(sourceType1) - this.getSourcePriority(sourceType2);\n    }\n  }, {\n    key: \"isSource\",\n    value: function isSource(source) {\n      return this.avatarSources.includes(source);\n    }\n  }, {\n    key: \"isTextAvatar\",\n    value: function isTextAvatar(sourceType) {\n      return [AvatarSource.INITIALS, AvatarSource.VALUE].includes(sourceType);\n    }\n  }, {\n    key: \"buildSourceKey\",\n    value: function buildSourceKey(source) {\n      return source.sourceType + '-' + source.sourceId;\n    }\n  }, {\n    key: \"sourceHasFailedBefore\",\n    value: function sourceHasFailedBefore(source) {\n      return this.failedSources.has(this.buildSourceKey(source));\n    }\n  }, {\n    key: \"markSourceAsFailed\",\n    value: function markSourceAsFailed(source) {\n      this.failedSources.set(this.buildSourceKey(source), source);\n    }\n  }, {\n    key: \"overrideAvatarSources\",\n    value: function overrideAvatarSources() {\n      this.avatarSources = this.avatarConfigService.getAvatarSources(defaultSources);\n    }\n  }, {\n    key: \"overrideAvatarColors\",\n    value: function overrideAvatarColors() {\n      this.avatarColors = this.avatarConfigService.getAvatarColors(defaultColors);\n    }\n  }, {\n    key: \"calculateAsciiCode\",\n    value: function calculateAsciiCode(value) {\n      return value.split('').map(function (letter) {\n        return letter.charCodeAt(0);\n      }).reduce(function (previous, current) {\n        return previous + current;\n      });\n    }\n  }, {\n    key: \"getSourcePriority\",\n    value: function getSourcePriority(sourceType) {\n      return this.avatarSources.indexOf(sourceType);\n    }\n  }]);\n\n  return AvatarService;\n}();\n\nAvatarService.decorators = [{\n  type: Injectable\n}];\n\nAvatarService.ctorParameters = function () {\n  return [{\n    type: HttpClient\n  }, {\n    type: AvatarConfigService\n  }];\n};\n/**\n * Universal avatar component that\n * generates avatar from different sources\n *\n * export\n * class AvatarComponent\n * implements {OnChanges}\n */\n\n\nvar AvatarComponent = /*#__PURE__*/function () {\n  function AvatarComponent(sourceFactory, avatarService) {\n    _classCallCheck(this, AvatarComponent);\n\n    this.sourceFactory = sourceFactory;\n    this.avatarService = avatarService;\n    this.round = true;\n    this.size = 50;\n    this.textSizeRatio = 3;\n    this.fgColor = '#FFF';\n    this.style = {};\n    this.cornerRadius = 0;\n    this.initialsSize = 0;\n    this.clickOnAvatar = new EventEmitter();\n    this.isAlive = true;\n    this.avatarSrc = null;\n    this.avatarText = null;\n    this.avatarStyle = {};\n    this.hostStyle = {};\n    this.currentIndex = -1;\n    this.sources = [];\n  }\n\n  _createClass(AvatarComponent, [{\n    key: \"onAvatarClicked\",\n    value: function onAvatarClicked() {\n      this.clickOnAvatar.emit(this.sources[this.currentIndex]);\n    }\n    /**\n     * Detect inputs change\n     *\n     * param {{ [propKey: string]: SimpleChange }} changes\n     *\n     * memberof AvatarComponent\n     */\n\n  }, {\n    key: \"ngOnChanges\",\n    value: function ngOnChanges(changes) {\n      for (var propName in changes) {\n        if (this.avatarService.isSource(propName)) {\n          var sourceType = AvatarSource[propName.toUpperCase()];\n          var currentValue = changes[propName].currentValue;\n\n          if (currentValue && typeof currentValue === 'string') {\n            this.addSource(sourceType, currentValue);\n          } else {\n            this.removeSource(sourceType);\n          }\n        }\n      } // reinitialize the avatar component when a source property value has changed\n      // the fallback system must be re-invoked with the new values.\n\n\n      this.initializeAvatar();\n    }\n    /**\n     * Fetch avatar source\n     *\n     * memberOf AvatarComponent\n     */\n\n  }, {\n    key: \"fetchAvatarSource\",\n    value: function fetchAvatarSource() {\n      var previousSource = this.sources[this.currentIndex];\n\n      if (previousSource) {\n        this.avatarService.markSourceAsFailed(previousSource);\n      }\n\n      var source = this.findNextSource();\n\n      if (!source) {\n        return;\n      }\n\n      if (this.avatarService.isTextAvatar(source.sourceType)) {\n        this.buildTextAvatar(source);\n        this.avatarSrc = null;\n      } else {\n        this.buildImageAvatar(source);\n      }\n    }\n  }, {\n    key: \"findNextSource\",\n    value: function findNextSource() {\n      while (++this.currentIndex < this.sources.length) {\n        var source = this.sources[this.currentIndex];\n\n        if (source && !this.avatarService.sourceHasFailedBefore(source)) {\n          return source;\n        }\n      }\n\n      return null;\n    }\n  }, {\n    key: \"ngOnDestroy\",\n    value: function ngOnDestroy() {\n      this.isAlive = false;\n    }\n    /**\n     * Initialize the avatar component and its fallback system\n     */\n\n  }, {\n    key: \"initializeAvatar\",\n    value: function initializeAvatar() {\n      this.currentIndex = -1;\n\n      if (this.sources.length > 0) {\n        this.sortAvatarSources();\n        this.fetchAvatarSource();\n        this.hostStyle = {\n          width: this.size + 'px',\n          height: this.size + 'px'\n        };\n      }\n    }\n  }, {\n    key: \"sortAvatarSources\",\n    value: function sortAvatarSources() {\n      var _this5 = this;\n\n      this.sources.sort(function (source1, source2) {\n        return _this5.avatarService.compareSources(source1.sourceType, source2.sourceType);\n      });\n    }\n  }, {\n    key: \"buildTextAvatar\",\n    value: function buildTextAvatar(avatarSource) {\n      this.avatarText = avatarSource.getAvatar(+this.initialsSize);\n      this.avatarStyle = this.getInitialsStyle(avatarSource.sourceId);\n    }\n  }, {\n    key: \"buildImageAvatar\",\n    value: function buildImageAvatar(avatarSource) {\n      this.avatarStyle = this.getImageStyle();\n\n      if (avatarSource instanceof AsyncSource) {\n        this.fetchAndProcessAsyncAvatar(avatarSource);\n      } else {\n        this.avatarSrc = avatarSource.getAvatar(+this.size);\n      }\n    }\n    /**\n     *\n     * returns initials style\n     *\n     * memberOf AvatarComponent\n     */\n\n  }, {\n    key: \"getInitialsStyle\",\n    value: function getInitialsStyle(avatarValue) {\n      return Object.assign({\n        textAlign: 'center',\n        borderRadius: this.round ? '100%' : this.cornerRadius + 'px',\n        border: this.borderColor ? '1px solid ' + this.borderColor : '',\n        textTransform: 'uppercase',\n        color: this.fgColor,\n        backgroundColor: this.bgColor ? this.bgColor : this.avatarService.getRandomColor(avatarValue),\n        font: Math.floor(+this.size / this.textSizeRatio) + 'px Helvetica, Arial, sans-serif',\n        lineHeight: this.size + 'px'\n      }, this.style);\n    }\n    /**\n     *\n     * returns image style\n     *\n     * memberOf AvatarComponent\n     */\n\n  }, {\n    key: \"getImageStyle\",\n    value: function getImageStyle() {\n      return Object.assign({\n        maxWidth: '100%',\n        borderRadius: this.round ? '50%' : this.cornerRadius + 'px',\n        border: this.borderColor ? '1px solid ' + this.borderColor : '',\n        width: this.size + 'px',\n        height: this.size + 'px'\n      }, this.style);\n    }\n    /**\n     * Fetch avatar image asynchronously.\n     *\n     * param {Source} source represents avatar source\n     * memberof AvatarComponent\n     */\n\n  }, {\n    key: \"fetchAndProcessAsyncAvatar\",\n    value: function fetchAndProcessAsyncAvatar(source) {\n      var _this6 = this;\n\n      if (this.avatarService.sourceHasFailedBefore(source)) {\n        return;\n      }\n\n      this.avatarService.fetchAvatar(source.getAvatar(+this.size)).pipe(takeWhile(function () {\n        return _this6.isAlive;\n      }), map(function (response) {\n        return source.processResponse(response, +_this6.size);\n      })).subscribe(function (avatarSrc) {\n        return _this6.avatarSrc = avatarSrc;\n      }, function (err) {\n        _this6.fetchAvatarSource();\n      });\n    }\n    /**\n     * Add avatar source\n     *\n     * param sourceType avatar source type e.g facebook,twitter, etc.\n     * param sourceValue  source value e.g facebookId value, etc.\n     */\n\n  }, {\n    key: \"addSource\",\n    value: function addSource(sourceType, sourceValue) {\n      var source = this.sources.find(function (s) {\n        return s.sourceType === sourceType;\n      });\n\n      if (source) {\n        source.sourceId = sourceValue;\n      } else {\n        this.sources.push(this.sourceFactory.newInstance(sourceType, sourceValue));\n      }\n    }\n    /**\n     * Remove avatar source\n     *\n     * param sourceType avatar source type e.g facebook,twitter, etc.\n     */\n\n  }, {\n    key: \"removeSource\",\n    value: function removeSource(sourceType) {\n      this.sources = this.sources.filter(function (source) {\n        return source.sourceType !== sourceType;\n      });\n    }\n  }]);\n\n  return AvatarComponent;\n}();\n\nAvatarComponent.decorators = [{\n  type: Component,\n  args: [{\n    // tslint:disable-next-line:component-selector\n    selector: 'ngx-avatar',\n    template: \"\\n    <div\\n      (click)=\\\"onAvatarClicked()\\\"\\n      class=\\\"avatar-container\\\"\\n      [ngStyle]=\\\"hostStyle\\\"\\n    >\\n      <img\\n        *ngIf=\\\"avatarSrc; else textAvatar\\\"\\n        [src]=\\\"avatarSrc\\\"\\n        [width]=\\\"size\\\"\\n        [height]=\\\"size\\\"\\n        [ngStyle]=\\\"avatarStyle\\\"\\n        (error)=\\\"fetchAvatarSource()\\\"\\n        class=\\\"avatar-content\\\"\\n        loading=\\\"lazy\\\"\\n      />\\n      <ng-template #textAvatar>\\n        <div *ngIf=\\\"avatarText\\\" class=\\\"avatar-content\\\" [ngStyle]=\\\"avatarStyle\\\">\\n          {{ avatarText }}\\n        </div>\\n      </ng-template>\\n    </div>\\n  \",\n    styles: [\"\\n      :host {\\n        border-radius: 50%;\\n      }\\n    \"]\n  }]\n}];\n\nAvatarComponent.ctorParameters = function () {\n  return [{\n    type: SourceFactory\n  }, {\n    type: AvatarService\n  }];\n};\n\nAvatarComponent.propDecorators = {\n  round: [{\n    type: Input\n  }],\n  size: [{\n    type: Input\n  }],\n  textSizeRatio: [{\n    type: Input\n  }],\n  bgColor: [{\n    type: Input\n  }],\n  fgColor: [{\n    type: Input\n  }],\n  borderColor: [{\n    type: Input\n  }],\n  style: [{\n    type: Input\n  }],\n  cornerRadius: [{\n    type: Input\n  }],\n  facebook: [{\n    type: Input,\n    args: ['facebookId']\n  }],\n  twitter: [{\n    type: Input,\n    args: ['twitterId']\n  }],\n  google: [{\n    type: Input,\n    args: ['googleId']\n  }],\n  instagram: [{\n    type: Input,\n    args: ['instagramId']\n  }],\n  vkontakte: [{\n    type: Input,\n    args: ['vkontakteId']\n  }],\n  skype: [{\n    type: Input,\n    args: ['skypeId']\n  }],\n  gravatar: [{\n    type: Input,\n    args: ['gravatarId']\n  }],\n  github: [{\n    type: Input,\n    args: ['githubId']\n  }],\n  custom: [{\n    type: Input,\n    args: ['src']\n  }],\n  initials: [{\n    type: Input,\n    args: ['name']\n  }],\n  value: [{\n    type: Input\n  }],\n  placeholder: [{\n    type: Input\n  }],\n  initialsSize: [{\n    type: Input\n  }],\n  clickOnAvatar: [{\n    type: Output\n  }]\n};\n\nvar AvatarModule = /*#__PURE__*/function () {\n  function AvatarModule() {\n    _classCallCheck(this, AvatarModule);\n  }\n\n  _createClass(AvatarModule, null, [{\n    key: \"forRoot\",\n    value: function forRoot(avatarConfig) {\n      return {\n        ngModule: AvatarModule,\n        providers: [{\n          provide: AVATAR_CONFIG,\n          useValue: avatarConfig ? avatarConfig : {}\n        }]\n      };\n    }\n  }]);\n\n  return AvatarModule;\n}();\n\nAvatarModule.decorators = [{\n  type: NgModule,\n  args: [{\n    imports: [CommonModule],\n    declarations: [AvatarComponent],\n    providers: [SourceFactory, AvatarService, AvatarConfigService],\n    exports: [AvatarComponent]\n  }]\n}];\n/*\n * Public API Surface of ngx-avatar\n */\n\n/**\n * Generated bundle index. Do not edit.\n */\n\nexport { AvatarComponent, AvatarModule, AvatarService, AvatarSource, defaultColors, defaultSources, SourceFactory as ɵa, AvatarConfigService as ɵb, AVATAR_CONFIG as ɵc };","map":{"version":3,"sources":["../../../projects/ngx-avatar/src/lib/sources/async-source.ts","../../../projects/ngx-avatar/src/lib/sources/avatar-source.enum.ts","../../../projects/ngx-avatar/src/lib/sources/facebook.ts","../../../projects/ngx-avatar/src/lib/sources/twitter.ts","../../../projects/ngx-avatar/src/lib/sources/google.ts","../../../projects/ngx-avatar/src/lib/sources/instagram.ts","../../../projects/ngx-avatar/src/lib/sources/custom.ts","../../../projects/ngx-avatar/src/lib/sources/initials.ts","../../../projects/ngx-avatar/src/lib/sources/gravatar.ts","../../../projects/ngx-avatar/src/lib/sources/skype.ts","../../../projects/ngx-avatar/src/lib/sources/value.ts","../../../projects/ngx-avatar/src/lib/sources/vkontakte.ts","../../../projects/ngx-avatar/src/lib/sources/github.ts","../../../projects/ngx-avatar/src/lib/sources/source.factory.ts","../../../projects/ngx-avatar/src/lib/avatar-config.token.ts","../../../projects/ngx-avatar/src/lib/avatar-config.service.ts","../../../projects/ngx-avatar/src/lib/avatar.service.ts","../../../projects/ngx-avatar/src/lib/avatar.component.ts","../../../projects/ngx-avatar/src/lib/avatar.module.ts","../../../projects/ngx-avatar/src/public_api.ts"],"names":[],"mappings":"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","sourcesContent":["import { Source } from './source';\nimport { AvatarSource } from './avatar-source.enum';\n\n/**\n * Contract of all async sources.\n * Every async source must implement the processResponse method that extracts the avatar url from the data\n */\nexport abstract class AsyncSource implements Source {\n  readonly abstract sourceType: AvatarSource;\n\n  constructor(public sourceId: string) {}\n\n  abstract getAvatar(size: number): string;\n  abstract processResponse(data: unknown, size?: number): string | null;\n}\n","export enum AvatarSource {\n  FACEBOOK = 'facebook',\n  GOOGLE = 'google',\n  TWITTER = 'twitter',\n  INSTAGRAM = 'instagram',\n  VKONTAKTE = 'vkontakte',\n  SKYPE = 'skype',\n  GRAVATAR = 'gravatar',\n  GITHUB = 'github',\n  CUSTOM = 'custom',\n  INITIALS = 'initials',\n  VALUE = 'value'\n}\n","import { Source } from './source';\nimport { AvatarSource } from './avatar-source.enum';\n/**\n *  Facebook source implementation.\n *  Fetch avatar source based on facebook identifier\n *  and image size\n */\nexport class Facebook implements Source {\n  readonly sourceType: AvatarSource = AvatarSource.FACEBOOK;\n\n  constructor(public sourceId: string) {}\n\n  public getAvatar(size: number): string {\n    return (\n      'https://graph.facebook.com/' +\n      `${this.sourceId}/picture?width=${size}&height=${size}`\n    );\n  }\n}\n","import { Source } from './source';\nimport { AvatarSource } from './avatar-source.enum';\n\n/**\n *  Twitter source implementation.\n *  Fetch avatar source based on google identifier\n *  and image size\n */\nexport class Twitter implements Source {\n  readonly sourceType: AvatarSource = AvatarSource.TWITTER;\n\n  constructor(public sourceId: string) {}\n\n  public getAvatar(size: number): string {\n    const twitterImgSize = this.getImageSize(size);\n    return `https://twitter.com/${\n      this.sourceId\n    }/profile_image?size=${twitterImgSize}`;\n  }\n\n  private getImageSize(size: number) {\n    if (size <= 24) {\n      return 'mini';\n    }\n\n    if (size <= 48) {\n      return 'normal';\n    }\n\n    if (size <= 73) {\n      return 'bigger';\n    }\n\n    return 'original';\n  }\n}\n","import { AsyncSource } from './async-source';\nimport { AvatarSource } from './avatar-source.enum';\n\n/**\n *  Google source implementation.\n *  Fetch avatar source based on google identifier\n *  and image size\n */\nexport class Google extends AsyncSource {\n  readonly sourceType: AvatarSource = AvatarSource.GOOGLE;\n\n  constructor(sourceId: string) {\n    super(sourceId);\n  }\n\n  public getAvatar(): string {\n    return `https://picasaweb.google.com/data/entry/api/user/${\n      this.sourceId\n    }?alt=json`;\n  }\n\n  /**\n   * Extract google avatar from json data\n   */\n  public processResponse(data: { entry: { gphoto$thumbnail: { $t: string } } }, size?: number): string | null {\n    const avatarSrc = data.entry.gphoto$thumbnail.$t;\n    if (avatarSrc) {\n      return avatarSrc.replace('s64', 's' + size);\n    }\n\n    return null;\n  }\n}\n","import { AsyncSource } from './async-source';\nimport { AvatarSource } from './avatar-source.enum';\n\n/**\n *  Instagram source impelementation.\n *  Fetch avatar source based on instagram identifier\n */\nexport class Instagram extends AsyncSource {\n  readonly sourceType: AvatarSource = AvatarSource.INSTAGRAM;\n\n  constructor(sourceId: string) {\n    super(sourceId);\n  }\n\n  public getAvatar(): string {\n    return `https://www.instagram.com/${this.sourceId}/?__a=1`;\n  }\n\n  /**\n   * extract instagram avatar from json data\n   */\n  public processResponse(data: { graphql: { user: { profile_pic_url_hd: string } } }, size?: number): string {\n    return `${data.graphql.user.profile_pic_url_hd}&s=${size}`;\n  }\n}\n","import { Source } from './source';\nimport { AvatarSource } from './avatar-source.enum';\n/**\n *  Custom source implementation.\n *  return custom image as an avatar\n *\n */\nexport class Custom implements Source {\n  readonly sourceType: AvatarSource = AvatarSource.CUSTOM;\n\n  constructor(public sourceId: string) {}\n\n  public getAvatar(): string {\n    return this.sourceId;\n  }\n}\n","import { Source } from './source';\nimport { AvatarSource } from './avatar-source.enum';\n\n/**\n * Initials source implementation.\n * return the initials of the given value\n */\nexport class Initials implements Source {\n  readonly sourceType: AvatarSource = AvatarSource.INITIALS;\n\n  constructor(public sourceId: string) {}\n\n  public getAvatar(size: number): string {\n    return this.getInitials(this.sourceId, size);\n  }\n\n  /**\n   * Returns the initial letters of a name in a string.\n   */\n  private getInitials(name: string, size: number): string {\n    name = name.trim();\n\n    if (!name) {\n      return '';\n    }\n\n    const initials = name.split(' ');\n\n    if (size && size < initials.length) {\n      return this.constructInitials(initials.slice(0, size));\n    } else {\n      return this.constructInitials(initials);\n    }\n  }\n\n  /**\n   * Iterates a person's name string to get the initials of each word in uppercase.\n   */\n  private constructInitials(elements: string[]): string {\n    if (!elements || !elements.length) {\n      return '';\n    }\n\n    return elements\n      .filter(element => element && element.length > 0)\n      .map(element => element[0].toUpperCase())\n      .join('');\n  }\n}\n","import { Md5 } from 'ts-md5';\nimport { Source } from './source';\nimport { AvatarSource } from './avatar-source.enum';\n\nfunction isRetina(): boolean {\n  if (typeof window !== 'undefined' && window !== null) {\n    if (window.devicePixelRatio > 1.25) {\n      return true;\n    }\n\n    const mediaQuery = '(-webkit-min-device-pixel-ratio: 1.25), (min--moz-device-pixel-ratio: 1.25), (-o-min-device-pixel-ratio: 5/4), (min-resolution: 1.25dppx)';\n    if (window.matchMedia && window.matchMedia(mediaQuery).matches) {\n      return true;\n    }\n  }\n\n  return false;\n}\n\n/**\n *  Gravatar source implementation.\n *  Fetch avatar source based on gravatar email\n */\nexport class Gravatar implements Source {\n  readonly sourceType: AvatarSource = AvatarSource.GRAVATAR;\n  public sourceId: string;\n\n  constructor(public value: string) {\n    this.sourceId = value.match('^[a-f0-9]{32}$')\n      ? value\n      : Md5.hashStr(value).toString();\n  }\n\n  public getAvatar(size: number): string {\n    const avatarSize = isRetina() ? size * 2 : size;\n    return `https://secure.gravatar.com/avatar/${\n      this.sourceId\n    }?s=${avatarSize}&d=404`;\n  }\n}\n","import { Source } from './source';\nimport { AvatarSource } from './avatar-source.enum';\n/**\n *  Skype source implementation.\n *  Fetch avatar source based on skype identifier\n */\nexport class Skype implements Source {\n  readonly sourceType: AvatarSource = AvatarSource.SKYPE;\n\n  constructor(public sourceId: string) {}\n\n  public getAvatar(): string {\n    return `https://api.skype.com/users/${this.sourceId}/profile/avatar`;\n  }\n}\n","import { Source } from './source';\nimport { AvatarSource } from './avatar-source.enum';\n\n/**\n *  Value source implementation.\n *  return the value as avatar\n */\nexport class Value implements Source {\n  readonly sourceType: AvatarSource = AvatarSource.VALUE;\n\n  constructor(public sourceId: string) {}\n\n  public getAvatar(): string {\n    return this.sourceId;\n  }\n}\n","import { AsyncSource } from './async-source';\nimport { AvatarSource } from './avatar-source.enum';\n\n/**\n *  Vkontakte source implementation.\n *  Fetch avatar source based on vkontakte identifier\n *  and image size\n */\nconst apiVersion = 5.8;\n\nexport class Vkontakte extends AsyncSource {\n  readonly sourceType: AvatarSource = AvatarSource.VKONTAKTE;\n\n  constructor(sourceId: string) {\n    super(sourceId);\n  }\n\n  public getAvatar(size: number): string {\n    const imgSize = this.getImageSize(size);\n    return `https://api.vk.com/method/users.get?user_id=${\n      this.sourceId\n    }&v=${apiVersion}&fields=${imgSize}`;\n  }\n\n  /**\n   * extract vkontakte avatar from json data\n   */\n  public processResponse(data: {\n    response: {\n      [key: string]: string;\n    }[]\n  }): string | null {\n    // avatar key property is the size used to generate avatar url\n    // size property is always the last key in the response object\n    const sizeProperty = Object.keys(data['response'][0]).pop();\n    if (!sizeProperty) {\n      return null;\n    }\n    // return avatar src\n    return data['response'][0][sizeProperty] || null;\n  }\n\n  /**\n   * Returns image size related to vkontakte API\n   */\n  private getImageSize(size: number): string {\n    if (size <= 50) {\n      return 'photo_50';\n    }\n\n    if (size <= 100) {\n      return 'photo_100';\n    }\n\n    if (size <= 200) {\n      return 'photo_200';\n    }\n\n    return 'photo_max';\n  }\n}\n","import { AsyncSource } from './async-source';\nimport { AvatarSource } from './avatar-source.enum';\n\n/**\n *  GitHub source implementation.\n *  Fetch avatar source based on github identifier\n */\nexport class Github extends AsyncSource {\n  readonly sourceType: AvatarSource = AvatarSource.GITHUB;\n\n  constructor(sourceId: string) {\n    super(sourceId);\n  }\n\n  public getAvatar(): string {\n    return `https://api.github.com/users/${this.sourceId}`;\n  }\n\n  /**\n   * extract github avatar from json data\n   */\n  public processResponse(data: { avatar_url: string }, size?: number): string {\n    if (size) {\n      return `${data.avatar_url}&s=${size}`;\n    }\n    return data.avatar_url;\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { Source } from './source';\nimport { Facebook } from './facebook';\nimport { Twitter } from './twitter';\nimport { Google } from './google';\nimport { Instagram } from './instagram';\nimport { Custom } from './custom';\nimport { Initials } from './initials';\nimport { Gravatar } from './gravatar';\nimport { Skype } from './skype';\nimport { Value } from './value';\nimport { Vkontakte } from './vkontakte';\nimport { Github } from './github';\nimport { SourceCreator } from './source.creator';\nimport { AvatarSource } from './avatar-source.enum';\n\n/**\n * Factory class that implements factory method pattern.\n * Used to create Source implementation class based\n * on the source Type\n */\n@Injectable()\nexport class SourceFactory {\n  private sources: { [key: string]: SourceCreator } = {};\n\n  constructor() {\n    this.sources[AvatarSource.FACEBOOK] = Facebook;\n    this.sources[AvatarSource.TWITTER] = Twitter;\n    this.sources[AvatarSource.GOOGLE] = Google;\n    this.sources[AvatarSource.INSTAGRAM] = Instagram;\n    this.sources[AvatarSource.SKYPE] = Skype;\n    this.sources[AvatarSource.GRAVATAR] = Gravatar;\n    this.sources[AvatarSource.CUSTOM] = Custom;\n    this.sources[AvatarSource.INITIALS] = Initials;\n    this.sources[AvatarSource.VALUE] = Value;\n    this.sources[AvatarSource.VKONTAKTE] = Vkontakte;\n    this.sources[AvatarSource.GITHUB] = Github;\n  }\n\n  public newInstance(sourceType: AvatarSource, sourceValue: string): Source {\n    return new this.sources[sourceType](sourceValue);\n  }\n}\n","import { InjectionToken } from '@angular/core';\n\nimport { AvatarConfig } from './avatar-config';\n/**\n * Token used to inject the AvatarConfig object\n */\nexport const AVATAR_CONFIG = new InjectionToken<AvatarConfig>('avatar.config');\n","import { Injectable, Inject, Optional } from '@angular/core';\n\nimport { AvatarSource } from './sources/avatar-source.enum';\nimport { AVATAR_CONFIG } from './avatar-config.token';\nimport { AvatarConfig } from './avatar-config';\n\n@Injectable()\nexport class AvatarConfigService {\n  constructor(\n    @Optional()\n    @Inject(AVATAR_CONFIG)\n    public userConfig: AvatarConfig\n  ) {}\n\n  public getAvatarSources(defaultSources: AvatarSource[]): AvatarSource[] {\n    if (\n      this.userConfig &&\n      this.userConfig.sourcePriorityOrder &&\n      this.userConfig.sourcePriorityOrder.length\n    ) {\n      const uniqueSources = [...new Set(this.userConfig.sourcePriorityOrder)];\n      const validSources = uniqueSources.filter(source =>\n        defaultSources.includes(source)\n      );\n      return [\n        ...validSources,\n        ...defaultSources.filter(source => !validSources.includes(source))\n      ];\n    }\n    return defaultSources;\n  }\n\n  public getAvatarColors(defaultColors: string[]): string[] {\n    return (\n      (this.userConfig &&\n        this.userConfig.colors &&\n        this.userConfig.colors.length &&\n        this.userConfig.colors) ||\n      defaultColors\n    );\n  }\n}\n","import { Injectable } from '@angular/core';\nimport { HttpClient } from '@angular/common/http';\n\nimport { Observable } from 'rxjs';\n\nimport { AvatarConfigService } from './avatar-config.service';\nimport { AvatarSource } from './sources/avatar-source.enum';\nimport { Source } from './sources/source';\n\n/**\n * list of Supported avatar sources\n */\nexport const defaultSources = [\n  AvatarSource.FACEBOOK,\n  AvatarSource.GOOGLE,\n  AvatarSource.TWITTER,\n  AvatarSource.INSTAGRAM,\n  AvatarSource.VKONTAKTE,\n  AvatarSource.SKYPE,\n  AvatarSource.GRAVATAR,\n  AvatarSource.GITHUB,\n  AvatarSource.CUSTOM,\n  AvatarSource.INITIALS,\n  AvatarSource.VALUE\n];\n\n/**\n * list of default colors\n */\nexport const defaultColors = [\n  '#1abc9c',\n  '#3498db',\n  '#f1c40f',\n  '#8e44ad',\n  '#e74c3c',\n  '#d35400',\n  '#2c3e50',\n  '#7f8c8d'\n];\n\n/**\n * Provides utilities methods related to Avatar component\n */\n@Injectable()\nexport class AvatarService {\n  public avatarSources: AvatarSource[] = defaultSources;\n  public avatarColors: string[] = defaultColors;\n\n  private readonly failedSources = new Map<string, Source>();\n\n  constructor(\n    private http: HttpClient,\n    private avatarConfigService: AvatarConfigService\n  ) {\n    this.overrideAvatarSources();\n    this.overrideAvatarColors();\n  }\n\n  public fetchAvatar(avatarUrl: string): Observable<unknown> {\n    return this.http.get(avatarUrl);\n  }\n\n  public getRandomColor(avatarText: string): string {\n    if (!avatarText) {\n      return 'transparent';\n    }\n    const asciiCodeSum = this.calculateAsciiCode(avatarText);\n    return this.avatarColors[asciiCodeSum % this.avatarColors.length];\n  }\n\n  public compareSources(\n    sourceType1: AvatarSource,\n    sourceType2: AvatarSource\n  ): number {\n    return (\n      this.getSourcePriority(sourceType1) - this.getSourcePriority(sourceType2)\n    );\n  }\n\n  public isSource(source: string): boolean {\n    return this.avatarSources.includes(source as AvatarSource);\n  }\n\n  public isTextAvatar(sourceType: AvatarSource): boolean {\n    return [AvatarSource.INITIALS, AvatarSource.VALUE].includes(sourceType);\n  }\n\n  private buildSourceKey(source: Source): string {\n    return source.sourceType + '-' + source.sourceId;\n  }\n\n  public sourceHasFailedBefore(source: Source): boolean {\n    return this.failedSources.has(this.buildSourceKey(source));\n  }\n\n  public markSourceAsFailed(source: Source): void {\n    this.failedSources.set(this.buildSourceKey(source), source);\n  }\n\n  private overrideAvatarSources(): void {\n    this.avatarSources = this.avatarConfigService.getAvatarSources(\n      defaultSources\n    );\n  }\n\n  private overrideAvatarColors(): void {\n    this.avatarColors = this.avatarConfigService.getAvatarColors(defaultColors);\n  }\n\n  private calculateAsciiCode(value: string): number {\n    return value\n      .split('')\n      .map(letter => letter.charCodeAt(0))\n      .reduce((previous, current) => previous + current);\n  }\n\n  private getSourcePriority(sourceType: AvatarSource) {\n    return this.avatarSources.indexOf(sourceType);\n  }\n}\n","import {\n  Component,\n  Input,\n  Output,\n  EventEmitter,\n  OnChanges,\n  SimpleChanges,\n  OnDestroy\n} from '@angular/core';\n\nimport { Source } from './sources/source';\nimport { AsyncSource } from './sources/async-source';\nimport { SourceFactory } from './sources/source.factory';\nimport { AvatarService } from './avatar.service';\nimport { AvatarSource } from './sources/avatar-source.enum';\nimport { takeWhile, map } from 'rxjs/operators';\n\ntype Style = Partial<CSSStyleDeclaration>;\n\n/**\n * Universal avatar component that\n * generates avatar from different sources\n *\n * export\n * class AvatarComponent\n * implements {OnChanges}\n */\n\n@Component({\n  // tslint:disable-next-line:component-selector\n  selector: 'ngx-avatar',\n  styles: [\n    `\n      :host {\n        border-radius: 50%;\n      }\n    `\n  ],\n  template: `\n    <div\n      (click)=\"onAvatarClicked()\"\n      class=\"avatar-container\"\n      [ngStyle]=\"hostStyle\"\n    >\n      <img\n        *ngIf=\"avatarSrc; else textAvatar\"\n        [src]=\"avatarSrc\"\n        [width]=\"size\"\n        [height]=\"size\"\n        [ngStyle]=\"avatarStyle\"\n        (error)=\"fetchAvatarSource()\"\n        class=\"avatar-content\"\n        loading=\"lazy\"\n      />\n      <ng-template #textAvatar>\n        <div *ngIf=\"avatarText\" class=\"avatar-content\" [ngStyle]=\"avatarStyle\">\n          {{ avatarText }}\n        </div>\n      </ng-template>\n    </div>\n  `\n})\nexport class AvatarComponent implements OnChanges, OnDestroy {\n  @Input()\n  public round = true;\n  @Input()\n  public size: string | number = 50;\n  @Input()\n  public textSizeRatio = 3;\n  @Input()\n  public bgColor: string | undefined;\n  @Input()\n  public fgColor = '#FFF';\n  @Input()\n  public borderColor: string | undefined;\n  @Input()\n  public style: Style = {};\n  @Input()\n  public cornerRadius: string | number = 0;\n  @Input('facebookId')\n  public facebook?: string | null;\n  @Input('twitterId')\n  public twitter?: string | null;\n  @Input('googleId')\n  public google?: string | null;\n  @Input('instagramId')\n  public instagram?: string | null;\n  @Input('vkontakteId')\n  public vkontakte?: string | null;\n  @Input('skypeId')\n  public skype?: string | null;\n  @Input('gravatarId')\n  public gravatar?: string | null;\n  @Input('githubId')\n  public github?: string | null;\n  @Input('src')\n  public custom?: string | null;\n  @Input('name')\n  public initials?: string | null;\n  @Input()\n  public value?: string | null;\n  @Input()\n  public placeholder?: string;\n  @Input()\n  public initialsSize: string | number = 0;\n\n  @Output()\n  public clickOnAvatar: EventEmitter<Source> = new EventEmitter<Source>();\n\n  public isAlive = true;\n  public avatarSrc: string | null = null;\n  public avatarText: string | null = null;\n  public avatarStyle: Style = {};\n  public hostStyle: Style = {};\n\n  private currentIndex = -1;\n  private sources: Source[] = [];\n\n  constructor(\n    public sourceFactory: SourceFactory,\n    private avatarService: AvatarService\n  ) {}\n\n  public onAvatarClicked(): void {\n    this.clickOnAvatar.emit(this.sources[this.currentIndex]);\n  }\n\n  /**\n   * Detect inputs change\n   *\n   * param {{ [propKey: string]: SimpleChange }} changes\n   *\n   * memberof AvatarComponent\n   */\n  public ngOnChanges(changes: SimpleChanges): void {\n    for (const propName in changes) {\n      if (this.avatarService.isSource(propName)) {\n        const sourceType: AvatarSource = AvatarSource[propName.toUpperCase() as keyof typeof AvatarSource] ;\n        const currentValue = changes[propName].currentValue;\n        if (currentValue && typeof currentValue === 'string') {\n          this.addSource(sourceType, currentValue);\n        } else {\n          this.removeSource(sourceType);\n        }\n      }\n    }\n    // reinitialize the avatar component when a source property value has changed\n    // the fallback system must be re-invoked with the new values.\n    this.initializeAvatar();\n  }\n\n  /**\n   * Fetch avatar source\n   *\n   * memberOf AvatarComponent\n   */\n  public fetchAvatarSource(): void {\n    const previousSource = this.sources[this.currentIndex];\n    if (previousSource) {\n      this.avatarService.markSourceAsFailed(previousSource);\n    }\n\n    const source = this.findNextSource();\n    if (!source) {\n      return;\n    }\n\n    if (this.avatarService.isTextAvatar(source.sourceType)) {\n      this.buildTextAvatar(source);\n      this.avatarSrc = null;\n    } else {\n      this.buildImageAvatar(source);\n    }\n  }\n\n  private findNextSource(): Source | null {\n    while (++this.currentIndex < this.sources.length) {\n      const source = this.sources[this.currentIndex];\n      if (source && !this.avatarService.sourceHasFailedBefore(source)) {\n        return source;\n      }\n    }\n\n    return null;\n  }\n\n  public ngOnDestroy(): void {\n    this.isAlive = false;\n  }\n\n  /**\n   * Initialize the avatar component and its fallback system\n   */\n  private initializeAvatar(): void {\n    this.currentIndex = -1;\n    if (this.sources.length > 0) {\n      this.sortAvatarSources();\n      this.fetchAvatarSource();\n      this.hostStyle = {\n        width: this.size + 'px',\n        height: this.size + 'px'\n      };\n    }\n  }\n\n  private sortAvatarSources(): void {\n    this.sources.sort((source1, source2) =>\n      this.avatarService.compareSources(source1.sourceType, source2.sourceType)\n    );\n  }\n\n  private buildTextAvatar(avatarSource: Source): void {\n    this.avatarText = avatarSource.getAvatar(+this.initialsSize);\n    this.avatarStyle = this.getInitialsStyle(avatarSource.sourceId);\n  }\n\n  private buildImageAvatar(avatarSource: Source): void {\n    this.avatarStyle = this.getImageStyle();\n    if (avatarSource instanceof AsyncSource) {\n      this.fetchAndProcessAsyncAvatar(avatarSource);\n    } else {\n      this.avatarSrc = avatarSource.getAvatar(+this.size);\n    }\n  }\n\n  /**\n   *\n   * returns initials style\n   *\n   * memberOf AvatarComponent\n   */\n  private getInitialsStyle(avatarValue: string): Style {\n    return {\n      textAlign: 'center',\n      borderRadius: this.round ? '100%' : this.cornerRadius + 'px',\n      border: this.borderColor ? '1px solid ' + this.borderColor : '',\n      textTransform: 'uppercase',\n      color: this.fgColor,\n      backgroundColor: this.bgColor\n        ? this.bgColor\n        : this.avatarService.getRandomColor(avatarValue),\n      font:\n        Math.floor(+this.size / this.textSizeRatio) +\n        'px Helvetica, Arial, sans-serif',\n      lineHeight: this.size + 'px',\n      ...this.style\n    };\n  }\n\n  /**\n   *\n   * returns image style\n   *\n   * memberOf AvatarComponent\n   */\n  private getImageStyle(): Style {\n    return {\n      maxWidth: '100%',\n      borderRadius: this.round ? '50%' : this.cornerRadius + 'px',\n      border: this.borderColor ? '1px solid ' + this.borderColor : '',\n      width: this.size + 'px',\n      height: this.size + 'px',\n      ...this.style,\n    };\n  }\n  /**\n   * Fetch avatar image asynchronously.\n   *\n   * param {Source} source represents avatar source\n   * memberof AvatarComponent\n   */\n  private fetchAndProcessAsyncAvatar(source: AsyncSource): void {\n    if (this.avatarService.sourceHasFailedBefore(source)) {\n      return;\n    }\n\n    this.avatarService\n        .fetchAvatar(source.getAvatar(+this.size))\n        .pipe(\n            takeWhile(() => this.isAlive),\n            map(response => source.processResponse(response, +this.size)),\n        )\n        .subscribe(\n            avatarSrc => (this.avatarSrc = avatarSrc),\n            err => {\n              this.fetchAvatarSource();\n            },\n        );\n  }\n\n  /**\n   * Add avatar source\n   *\n   * param sourceType avatar source type e.g facebook,twitter, etc.\n   * param sourceValue  source value e.g facebookId value, etc.\n   */\n  private addSource(sourceType: AvatarSource, sourceValue: string): void {\n    const source = this.sources.find(s => s.sourceType === sourceType);\n    if (source) {\n      source.sourceId = sourceValue;\n    } else {\n      this.sources.push(\n          this.sourceFactory.newInstance(sourceType, sourceValue),\n      );\n    }\n  }\n\n  /**\n   * Remove avatar source\n   *\n   * param sourceType avatar source type e.g facebook,twitter, etc.\n   */\n  private removeSource(sourceType: AvatarSource): void {\n    this.sources = this.sources.filter(source => source.sourceType !== sourceType);\n  }\n}\n","import { NgModule, ModuleWithProviders } from '@angular/core';\nimport { CommonModule } from '@angular/common';\n\nimport { AvatarComponent } from './avatar.component';\nimport { SourceFactory } from './sources/source.factory';\nimport { AvatarService } from './avatar.service';\nimport { AvatarConfig } from './avatar-config';\nimport { AVATAR_CONFIG } from './avatar-config.token';\nimport { AvatarConfigService } from './avatar-config.service';\n\n@NgModule({\n  imports: [CommonModule],\n  declarations: [AvatarComponent],\n  providers: [SourceFactory, AvatarService, AvatarConfigService],\n  exports: [AvatarComponent]\n})\nexport class AvatarModule {\n  static forRoot(avatarConfig?: AvatarConfig): ModuleWithProviders<AvatarModule> {\n    return {\n      ngModule: AvatarModule,\n      providers: [\n        { provide: AVATAR_CONFIG, useValue: avatarConfig ? avatarConfig : {} }\n      ]\n    };\n  }\n}\n","/*\n * Public API Surface of ngx-avatar\n */\nexport * from './lib/avatar.module';\nexport * from './lib/avatar.component';\nexport * from './lib/avatar-config';\nexport * from './lib/avatar.service';\nexport * from './lib/sources/avatar-source.enum';\n"]},"metadata":{},"sourceType":"module"}