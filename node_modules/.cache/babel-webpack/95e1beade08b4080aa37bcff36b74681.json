{"ast":null,"code":"import _slicedToArray from \"C:/Users/sebas/Downloads/uft_plantilla_frontend/uft_plantilla_frontend/node_modules/@babel/runtime/helpers/esm/slicedToArray\";\nimport _toConsumableArray from \"C:/Users/sebas/Downloads/uft_plantilla_frontend/uft_plantilla_frontend/node_modules/@babel/runtime/helpers/esm/toConsumableArray\";\nimport _inherits from \"C:/Users/sebas/Downloads/uft_plantilla_frontend/uft_plantilla_frontend/node_modules/@babel/runtime/helpers/esm/inherits\";\nimport _createSuper from \"C:/Users/sebas/Downloads/uft_plantilla_frontend/uft_plantilla_frontend/node_modules/@babel/runtime/helpers/esm/createSuper\";\nimport _createClass from \"C:/Users/sebas/Downloads/uft_plantilla_frontend/uft_plantilla_frontend/node_modules/@babel/runtime/helpers/esm/createClass\";\nimport _classCallCheck from \"C:/Users/sebas/Downloads/uft_plantilla_frontend/uft_plantilla_frontend/node_modules/@babel/runtime/helpers/esm/classCallCheck\";\nimport { InjectionToken, Injectable, Inject, ErrorHandler, NgModule } from '@angular/core';\nimport { ActionsSubject, UPDATE, INIT, ReducerObservable, ScannedActionsSubject, INITIAL_STATE, StateObservable, ReducerManagerDispatcher } from '@ngrx/store';\nimport { empty, Observable, of, merge, queueScheduler, ReplaySubject } from 'rxjs';\nimport { share, filter, map, concatMap, timeout, debounceTime, catchError, take, takeUntil, switchMap, skip, observeOn, withLatestFrom, scan } from 'rxjs/operators';\n/**\n * @fileoverview added by tsickle\n * Generated from: src/config.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @record\n */\n\nfunction DevToolsFeatureOptions() {}\n\nif (false) {\n  /** @type {?|undefined} */\n  DevToolsFeatureOptions.prototype.pause;\n  /** @type {?|undefined} */\n\n  DevToolsFeatureOptions.prototype.lock;\n  /** @type {?|undefined} */\n\n  DevToolsFeatureOptions.prototype.persist;\n  /** @type {?|undefined} */\n\n  DevToolsFeatureOptions.prototype.export;\n  /** @type {?|undefined} */\n\n  DevToolsFeatureOptions.prototype.import;\n  /** @type {?|undefined} */\n\n  DevToolsFeatureOptions.prototype.jump;\n  /** @type {?|undefined} */\n\n  DevToolsFeatureOptions.prototype.skip;\n  /** @type {?|undefined} */\n\n  DevToolsFeatureOptions.prototype.reorder;\n  /** @type {?|undefined} */\n\n  DevToolsFeatureOptions.prototype.dispatch;\n  /** @type {?|undefined} */\n\n  DevToolsFeatureOptions.prototype.test;\n}\n\nvar StoreDevtoolsConfig = /*#__PURE__*/_createClass(function StoreDevtoolsConfig() {\n  _classCallCheck(this, StoreDevtoolsConfig);\n\n  this.maxAge = false;\n});\n\nif (false) {\n  /** @type {?} */\n  StoreDevtoolsConfig.prototype.maxAge;\n  /** @type {?} */\n\n  StoreDevtoolsConfig.prototype.monitor;\n  /** @type {?} */\n\n  StoreDevtoolsConfig.prototype.actionSanitizer;\n  /** @type {?} */\n\n  StoreDevtoolsConfig.prototype.stateSanitizer;\n  /** @type {?} */\n\n  StoreDevtoolsConfig.prototype.name;\n  /** @type {?} */\n\n  StoreDevtoolsConfig.prototype.serialize;\n  /** @type {?} */\n\n  StoreDevtoolsConfig.prototype.logOnly;\n  /** @type {?} */\n\n  StoreDevtoolsConfig.prototype.features;\n  /** @type {?} */\n\n  StoreDevtoolsConfig.prototype.actionsBlocklist;\n  /** @type {?} */\n\n  StoreDevtoolsConfig.prototype.actionsSafelist;\n  /** @type {?} */\n\n  StoreDevtoolsConfig.prototype.predicate;\n}\n/** @type {?} */\n\n\nvar STORE_DEVTOOLS_CONFIG = new InjectionToken('@ngrx/devtools Options');\n/** @type {?} */\n\nvar INITIAL_OPTIONS = new InjectionToken('@ngrx/devtools Initial Config');\n/**\n * @return {?}\n */\n\nfunction noMonitor() {\n  return null;\n}\n/** @type {?} */\n\n\nvar DEFAULT_NAME = 'NgRx Store DevTools';\n/**\n * @param {?} _options\n * @return {?}\n */\n\nfunction createConfig(_options) {\n  /** @type {?} */\n  var DEFAULT_OPTIONS = {\n    maxAge: false,\n    monitor: noMonitor,\n    actionSanitizer: undefined,\n    stateSanitizer: undefined,\n    name: DEFAULT_NAME,\n    serialize: false,\n    logOnly: false,\n    // Add all features explicitly. This prevent buggy behavior for\n    // options like \"lock\" which might otherwise not show up.\n    features: {\n      pause: true,\n      // start/pause recording of dispatched actions\n      lock: true,\n      // lock/unlock dispatching actions and side effects\n      persist: true,\n      // persist states on page reloading\n      export: true,\n      // export history of actions in a file\n      import: 'custom',\n      // import history of actions from a file\n      jump: true,\n      // jump back and forth (time travelling)\n      skip: true,\n      // skip (cancel) actions\n      reorder: true,\n      // drag and drop actions in the history list\n      dispatch: true,\n      // dispatch custom actions or action creators\n      test: true\n    }\n  };\n  /** @type {?} */\n\n  var options = typeof _options === 'function' ? _options() : _options;\n  /** @type {?} */\n\n  var logOnly = options.logOnly ? {\n    pause: true,\n    export: true,\n    test: true\n  } : false;\n  /** @type {?} */\n\n  var features = options.features || logOnly || DEFAULT_OPTIONS.features;\n  /** @type {?} */\n\n  var config = Object.assign({}, DEFAULT_OPTIONS, {\n    features: features\n  }, options);\n\n  if (config.maxAge && config.maxAge < 2) {\n    throw new Error(\"Devtools 'maxAge' cannot be less than 2, got \".concat(config.maxAge));\n  }\n\n  return config;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/actions.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar PERFORM_ACTION = 'PERFORM_ACTION';\n/** @type {?} */\n\nvar REFRESH = 'REFRESH';\n/** @type {?} */\n\nvar RESET = 'RESET';\n/** @type {?} */\n\nvar ROLLBACK = 'ROLLBACK';\n/** @type {?} */\n\nvar COMMIT = 'COMMIT';\n/** @type {?} */\n\nvar SWEEP = 'SWEEP';\n/** @type {?} */\n\nvar TOGGLE_ACTION = 'TOGGLE_ACTION';\n/** @type {?} */\n\nvar SET_ACTIONS_ACTIVE = 'SET_ACTIONS_ACTIVE';\n/** @type {?} */\n\nvar JUMP_TO_STATE = 'JUMP_TO_STATE';\n/** @type {?} */\n\nvar JUMP_TO_ACTION = 'JUMP_TO_ACTION';\n/** @type {?} */\n\nvar IMPORT_STATE = 'IMPORT_STATE';\n/** @type {?} */\n\nvar LOCK_CHANGES = 'LOCK_CHANGES';\n/** @type {?} */\n\nvar PAUSE_RECORDING = 'PAUSE_RECORDING';\n\nvar PerformAction = /*#__PURE__*/_createClass(\n/**\n * @param {?} action\n * @param {?} timestamp\n */\nfunction PerformAction(action, timestamp) {\n  _classCallCheck(this, PerformAction);\n\n  this.action = action;\n  this.timestamp = timestamp;\n  this.type = PERFORM_ACTION;\n\n  if (typeof action.type === 'undefined') {\n    throw new Error('Actions may not have an undefined \"type\" property. ' + 'Have you misspelled a constant?');\n  }\n});\n\nif (false) {\n  /** @type {?} */\n  PerformAction.prototype.type;\n  /** @type {?} */\n\n  PerformAction.prototype.action;\n  /** @type {?} */\n\n  PerformAction.prototype.timestamp;\n}\n\nvar Refresh = /*#__PURE__*/_createClass(function Refresh() {\n  _classCallCheck(this, Refresh);\n\n  this.type = REFRESH;\n});\n\nif (false) {\n  /** @type {?} */\n  Refresh.prototype.type;\n}\n\nvar Reset = /*#__PURE__*/_createClass(\n/**\n * @param {?} timestamp\n */\nfunction Reset(timestamp) {\n  _classCallCheck(this, Reset);\n\n  this.timestamp = timestamp;\n  this.type = RESET;\n});\n\nif (false) {\n  /** @type {?} */\n  Reset.prototype.type;\n  /** @type {?} */\n\n  Reset.prototype.timestamp;\n}\n\nvar Rollback = /*#__PURE__*/_createClass(\n/**\n * @param {?} timestamp\n */\nfunction Rollback(timestamp) {\n  _classCallCheck(this, Rollback);\n\n  this.timestamp = timestamp;\n  this.type = ROLLBACK;\n});\n\nif (false) {\n  /** @type {?} */\n  Rollback.prototype.type;\n  /** @type {?} */\n\n  Rollback.prototype.timestamp;\n}\n\nvar Commit = /*#__PURE__*/_createClass(\n/**\n * @param {?} timestamp\n */\nfunction Commit(timestamp) {\n  _classCallCheck(this, Commit);\n\n  this.timestamp = timestamp;\n  this.type = COMMIT;\n});\n\nif (false) {\n  /** @type {?} */\n  Commit.prototype.type;\n  /** @type {?} */\n\n  Commit.prototype.timestamp;\n}\n\nvar Sweep = /*#__PURE__*/_createClass(function Sweep() {\n  _classCallCheck(this, Sweep);\n\n  this.type = SWEEP;\n});\n\nif (false) {\n  /** @type {?} */\n  Sweep.prototype.type;\n}\n\nvar ToggleAction = /*#__PURE__*/_createClass(\n/**\n * @param {?} id\n */\nfunction ToggleAction(id) {\n  _classCallCheck(this, ToggleAction);\n\n  this.id = id;\n  this.type = TOGGLE_ACTION;\n});\n\nif (false) {\n  /** @type {?} */\n  ToggleAction.prototype.type;\n  /** @type {?} */\n\n  ToggleAction.prototype.id;\n}\n\nvar SetActionsActive = /*#__PURE__*/_createClass(\n/**\n * @param {?} start\n * @param {?} end\n * @param {?=} active\n */\nfunction SetActionsActive(start, end) {\n  var active = arguments.length > 2 && arguments[2] !== undefined ? arguments[2] : true;\n\n  _classCallCheck(this, SetActionsActive);\n\n  this.start = start;\n  this.end = end;\n  this.active = active;\n  this.type = SET_ACTIONS_ACTIVE;\n});\n\nif (false) {\n  /** @type {?} */\n  SetActionsActive.prototype.type;\n  /** @type {?} */\n\n  SetActionsActive.prototype.start;\n  /** @type {?} */\n\n  SetActionsActive.prototype.end;\n  /** @type {?} */\n\n  SetActionsActive.prototype.active;\n}\n\nvar JumpToState = /*#__PURE__*/_createClass(\n/**\n * @param {?} index\n */\nfunction JumpToState(index) {\n  _classCallCheck(this, JumpToState);\n\n  this.index = index;\n  this.type = JUMP_TO_STATE;\n});\n\nif (false) {\n  /** @type {?} */\n  JumpToState.prototype.type;\n  /** @type {?} */\n\n  JumpToState.prototype.index;\n}\n\nvar JumpToAction = /*#__PURE__*/_createClass(\n/**\n * @param {?} actionId\n */\nfunction JumpToAction(actionId) {\n  _classCallCheck(this, JumpToAction);\n\n  this.actionId = actionId;\n  this.type = JUMP_TO_ACTION;\n});\n\nif (false) {\n  /** @type {?} */\n  JumpToAction.prototype.type;\n  /** @type {?} */\n\n  JumpToAction.prototype.actionId;\n}\n\nvar ImportState = /*#__PURE__*/_createClass(\n/**\n * @param {?} nextLiftedState\n */\nfunction ImportState(nextLiftedState) {\n  _classCallCheck(this, ImportState);\n\n  this.nextLiftedState = nextLiftedState;\n  this.type = IMPORT_STATE;\n});\n\nif (false) {\n  /** @type {?} */\n  ImportState.prototype.type;\n  /** @type {?} */\n\n  ImportState.prototype.nextLiftedState;\n}\n\nvar LockChanges = /*#__PURE__*/_createClass(\n/**\n * @param {?} status\n */\nfunction LockChanges(status) {\n  _classCallCheck(this, LockChanges);\n\n  this.status = status;\n  this.type = LOCK_CHANGES;\n});\n\nif (false) {\n  /** @type {?} */\n  LockChanges.prototype.type;\n  /** @type {?} */\n\n  LockChanges.prototype.status;\n}\n\nvar PauseRecording = /*#__PURE__*/_createClass(\n/**\n * @param {?} status\n */\nfunction PauseRecording(status) {\n  _classCallCheck(this, PauseRecording);\n\n  this.status = status;\n  this.type = PAUSE_RECORDING;\n});\n\nif (false) {\n  /** @type {?} */\n  PauseRecording.prototype.type;\n  /** @type {?} */\n\n  PauseRecording.prototype.status;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/devtools-dispatcher.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar DevtoolsDispatcher = /*#__PURE__*/function (_ActionsSubject) {\n  _inherits(DevtoolsDispatcher, _ActionsSubject);\n\n  var _super = _createSuper(DevtoolsDispatcher);\n\n  function DevtoolsDispatcher() {\n    _classCallCheck(this, DevtoolsDispatcher);\n\n    return _super.apply(this, arguments);\n  }\n\n  return _createClass(DevtoolsDispatcher);\n}(ActionsSubject);\n\nDevtoolsDispatcher.decorators = [{\n  type: Injectable\n}];\n/**\n * @fileoverview added by tsickle\n * Generated from: src/utils.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @param {?} first\n * @param {?} second\n * @return {?}\n */\n\nfunction difference(first, second) {\n  return first.filter(\n  /**\n  * @param {?} item\n  * @return {?}\n  */\n  function (item) {\n    return second.indexOf(item) < 0;\n  });\n}\n/**\n * Provides an app's view into the state of the lifted store.\n * @param {?} liftedState\n * @return {?}\n */\n\n\nfunction unliftState(liftedState) {\n  var computedStates = liftedState.computedStates,\n      currentStateIndex = liftedState.currentStateIndex; // At start up NgRx dispatches init actions,\n  // When these init actions are being filtered out by the predicate or safe/block list options\n  // we don't have a complete computed states yet.\n  // At this point it could happen that we're out of bounds, when this happens we fall back to the last known state\n\n  if (currentStateIndex >= computedStates.length) {\n    var _state = computedStates[computedStates.length - 1].state;\n    return _state;\n  }\n\n  var state = computedStates[currentStateIndex].state;\n  return state;\n}\n/**\n * @param {?} liftedState\n * @return {?}\n */\n\n\nfunction unliftAction(liftedState) {\n  return liftedState.actionsById[liftedState.nextActionId - 1];\n}\n/**\n * Lifts an app's action into an action on the lifted store.\n * @param {?} action\n * @return {?}\n */\n\n\nfunction liftAction(action) {\n  return new PerformAction(action, +Date.now());\n}\n/**\n * Sanitizes given actions with given function.\n * @param {?} actionSanitizer\n * @param {?} actions\n * @return {?}\n */\n\n\nfunction sanitizeActions(actionSanitizer, actions) {\n  return Object.keys(actions).reduce(\n  /**\n  * @param {?} sanitizedActions\n  * @param {?} actionIdx\n  * @return {?}\n  */\n  function (sanitizedActions, actionIdx) {\n    /** @type {?} */\n    var idx = Number(actionIdx);\n    sanitizedActions[idx] = sanitizeAction(actionSanitizer, actions[idx], idx);\n    return sanitizedActions;\n  },\n  /** @type {?} */\n  {});\n}\n/**\n * Sanitizes given action with given function.\n * @param {?} actionSanitizer\n * @param {?} action\n * @param {?} actionIdx\n * @return {?}\n */\n\n\nfunction sanitizeAction(actionSanitizer, action, actionIdx) {\n  return Object.assign(Object.assign({}, action), {\n    action: actionSanitizer(action.action, actionIdx)\n  });\n}\n/**\n * Sanitizes given states with given function.\n * @param {?} stateSanitizer\n * @param {?} states\n * @return {?}\n */\n\n\nfunction sanitizeStates(stateSanitizer, states) {\n  return states.map(\n  /**\n  * @param {?} computedState\n  * @param {?} idx\n  * @return {?}\n  */\n  function (computedState, idx) {\n    return {\n      state: sanitizeState(stateSanitizer, computedState.state, idx),\n      error: computedState.error\n    };\n  });\n}\n/**\n * Sanitizes given state with given function.\n * @param {?} stateSanitizer\n * @param {?} state\n * @param {?} stateIdx\n * @return {?}\n */\n\n\nfunction sanitizeState(stateSanitizer, state, stateIdx) {\n  return stateSanitizer(state, stateIdx);\n}\n/**\n * Read the config and tell if actions should be filtered\n * @param {?} config\n * @return {?}\n */\n\n\nfunction shouldFilterActions(config) {\n  return config.predicate || config.actionsSafelist || config.actionsBlocklist;\n}\n/**\n * Return a full filtered lifted state\n * @param {?} liftedState\n * @param {?=} predicate\n * @param {?=} safelist\n * @param {?=} blocklist\n * @return {?}\n */\n\n\nfunction filterLiftedState(liftedState, predicate, safelist, blocklist) {\n  /** @type {?} */\n  var filteredStagedActionIds = [];\n  /** @type {?} */\n\n  var filteredActionsById = {};\n  /** @type {?} */\n\n  var filteredComputedStates = [];\n  liftedState.stagedActionIds.forEach(\n  /**\n  * @param {?} id\n  * @param {?} idx\n  * @return {?}\n  */\n  function (id, idx) {\n    /** @type {?} */\n    var liftedAction = liftedState.actionsById[id];\n    if (!liftedAction) return;\n\n    if (idx && isActionFiltered(liftedState.computedStates[idx], liftedAction, predicate, safelist, blocklist)) {\n      return;\n    }\n\n    filteredActionsById[id] = liftedAction;\n    filteredStagedActionIds.push(id);\n    filteredComputedStates.push(liftedState.computedStates[idx]);\n  });\n  return Object.assign(Object.assign({}, liftedState), {\n    stagedActionIds: filteredStagedActionIds,\n    actionsById: filteredActionsById,\n    computedStates: filteredComputedStates\n  });\n}\n/**\n * Return true is the action should be ignored\n * @param {?} state\n * @param {?} action\n * @param {?=} predicate\n * @param {?=} safelist\n * @param {?=} blockedlist\n * @return {?}\n */\n\n\nfunction isActionFiltered(state, action, predicate, safelist, blockedlist) {\n  /** @type {?} */\n  var predicateMatch = predicate && !predicate(state, action.action);\n  /** @type {?} */\n\n  var safelistMatch = safelist && !action.action.type.match(safelist.map(\n  /**\n  * @param {?} s\n  * @return {?}\n  */\n  function (s) {\n    return escapeRegExp(s);\n  }).join('|'));\n  /** @type {?} */\n\n  var blocklistMatch = blockedlist && action.action.type.match(blockedlist.map(\n  /**\n  * @param {?} s\n  * @return {?}\n  */\n  function (s) {\n    return escapeRegExp(s);\n  }).join('|'));\n  return predicateMatch || safelistMatch || blocklistMatch;\n}\n/**\n * Return string with escaped RegExp special characters\n * https://stackoverflow.com/a/6969486/1337347\n * @param {?} s\n * @return {?}\n */\n\n\nfunction escapeRegExp(s) {\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/extension.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar ExtensionActionTypes = {\n  START: 'START',\n  DISPATCH: 'DISPATCH',\n  STOP: 'STOP',\n  ACTION: 'ACTION'\n};\n/** @type {?} */\n\nvar REDUX_DEVTOOLS_EXTENSION = new InjectionToken('Redux Devtools Extension');\n/**\n * @record\n */\n\nfunction ReduxDevtoolsExtensionConnection() {}\n\nif (false) {\n  /**\n   * @param {?} listener\n   * @return {?}\n   */\n  ReduxDevtoolsExtensionConnection.prototype.subscribe = function (listener) {};\n  /**\n   * @return {?}\n   */\n\n\n  ReduxDevtoolsExtensionConnection.prototype.unsubscribe = function () {};\n  /**\n   * @param {?} action\n   * @param {?} state\n   * @return {?}\n   */\n\n\n  ReduxDevtoolsExtensionConnection.prototype.send = function (action, state) {};\n  /**\n   * @param {?=} state\n   * @return {?}\n   */\n\n\n  ReduxDevtoolsExtensionConnection.prototype.init = function (state) {};\n  /**\n   * @param {?} anyErr\n   * @return {?}\n   */\n\n\n  ReduxDevtoolsExtensionConnection.prototype.error = function (anyErr) {};\n}\n/**\n * @record\n */\n\n\nfunction ReduxDevtoolsExtensionConfig() {}\n\nif (false) {\n  /** @type {?|undefined} */\n  ReduxDevtoolsExtensionConfig.prototype.features;\n  /** @type {?} */\n\n  ReduxDevtoolsExtensionConfig.prototype.name;\n  /** @type {?|undefined} */\n\n  ReduxDevtoolsExtensionConfig.prototype.maxAge;\n  /** @type {?|undefined} */\n\n  ReduxDevtoolsExtensionConfig.prototype.serialize;\n}\n/**\n * @record\n */\n\n\nfunction ReduxDevtoolsExtension() {}\n\nif (false) {\n  /**\n   * @param {?} options\n   * @return {?}\n   */\n  ReduxDevtoolsExtension.prototype.connect = function (options) {};\n  /**\n   * @param {?} action\n   * @param {?} state\n   * @param {?} options\n   * @return {?}\n   */\n\n\n  ReduxDevtoolsExtension.prototype.send = function (action, state, options) {};\n}\n\nvar DevtoolsExtension = /*#__PURE__*/function () {\n  /**\n   * @param {?} devtoolsExtension\n   * @param {?} config\n   * @param {?} dispatcher\n   */\n  function DevtoolsExtension(devtoolsExtension, config, dispatcher) {\n    _classCallCheck(this, DevtoolsExtension);\n\n    this.config = config;\n    this.dispatcher = dispatcher;\n    this.devtoolsExtension = devtoolsExtension;\n    this.createActionStreams();\n  }\n  /**\n   * @param {?} action\n   * @param {?} state\n   * @return {?}\n   */\n\n\n  _createClass(DevtoolsExtension, [{\n    key: \"notify\",\n    value: function notify(action, state) {\n      var _this = this;\n\n      if (!this.devtoolsExtension) {\n        return;\n      } // Check to see if the action requires a full update of the liftedState.\n      // If it is a simple action generated by the user's app and the recording\n      // is not locked/paused, only send the action and the current state (fast).\n      //\n      // A full liftedState update (slow: serializes the entire liftedState) is\n      // only required when:\n      //   a) redux-devtools-extension fires the @@Init action (ignored by\n      //      @ngrx/store-devtools)\n      //   b) an action is generated by an @ngrx module (e.g. @ngrx/effects/init\n      //      or @ngrx/store/update-reducers)\n      //   c) the state has been recomputed due to time-traveling\n      //   d) any action that is not a PerformAction to err on the side of\n      //      caution.\n\n\n      if (action.type === PERFORM_ACTION) {\n        if (state.isLocked || state.isPaused) {\n          return;\n        }\n        /** @type {?} */\n\n\n        var currentState = unliftState(state);\n\n        if (shouldFilterActions(this.config) && isActionFiltered(currentState, action, this.config.predicate, this.config.actionsSafelist, this.config.actionsBlocklist)) {\n          return;\n        }\n        /** @type {?} */\n\n\n        var sanitizedState = this.config.stateSanitizer ? sanitizeState(this.config.stateSanitizer, currentState, state.currentStateIndex) : currentState;\n        /** @type {?} */\n\n        var sanitizedAction = this.config.actionSanitizer ? sanitizeAction(this.config.actionSanitizer, action, state.nextActionId) : action;\n        this.sendToReduxDevtools(\n        /**\n        * @return {?}\n        */\n        function () {\n          return _this.extensionConnection.send(sanitizedAction, sanitizedState);\n        });\n      } else {\n        // Requires full state update\n\n        /** @type {?} */\n        var sanitizedLiftedState = Object.assign(Object.assign({}, state), {\n          stagedActionIds: state.stagedActionIds,\n          actionsById: this.config.actionSanitizer ? sanitizeActions(this.config.actionSanitizer, state.actionsById) : state.actionsById,\n          computedStates: this.config.stateSanitizer ? sanitizeStates(this.config.stateSanitizer, state.computedStates) : state.computedStates\n        });\n        this.sendToReduxDevtools(\n        /**\n        * @return {?}\n        */\n        function () {\n          return _this.devtoolsExtension.send(null, sanitizedLiftedState, _this.getExtensionConfig(_this.config));\n        });\n      }\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"createChangesObservable\",\n    value: function createChangesObservable() {\n      var _this2 = this;\n\n      if (!this.devtoolsExtension) {\n        return empty();\n      }\n\n      return new Observable(\n      /**\n      * @param {?} subscriber\n      * @return {?}\n      */\n      function (subscriber) {\n        /** @type {?} */\n        var connection = _this2.devtoolsExtension.connect(_this2.getExtensionConfig(_this2.config));\n\n        _this2.extensionConnection = connection;\n        connection.init();\n        connection.subscribe(\n        /**\n        * @param {?} change\n        * @return {?}\n        */\n        function (change) {\n          return subscriber.next(change);\n        });\n        return connection.unsubscribe;\n      });\n    }\n    /**\n     * @private\n     * @return {?}\n     */\n\n  }, {\n    key: \"createActionStreams\",\n    value: function createActionStreams() {\n      var _this3 = this;\n\n      // Listens to all changes\n\n      /** @type {?} */\n      var changes$ = this.createChangesObservable().pipe(share()); // Listen for the start action\n\n      /** @type {?} */\n\n      var start$ = changes$.pipe(filter(\n      /**\n      * @param {?} change\n      * @return {?}\n      */\n      function (change) {\n        return change.type === ExtensionActionTypes.START;\n      })); // Listen for the stop action\n\n      /** @type {?} */\n\n      var stop$ = changes$.pipe(filter(\n      /**\n      * @param {?} change\n      * @return {?}\n      */\n      function (change) {\n        return change.type === ExtensionActionTypes.STOP;\n      })); // Listen for lifted actions\n\n      /** @type {?} */\n\n      var liftedActions$ = changes$.pipe(filter(\n      /**\n      * @param {?} change\n      * @return {?}\n      */\n      function (change) {\n        return change.type === ExtensionActionTypes.DISPATCH;\n      }), map(\n      /**\n      * @param {?} change\n      * @return {?}\n      */\n      function (change) {\n        return _this3.unwrapAction(change.payload);\n      }), concatMap(\n      /**\n      * @param {?} action\n      * @return {?}\n      */\n      function (action) {\n        if (action.type === IMPORT_STATE) {\n          // State imports may happen in two situations:\n          // 1. Explicitly by user\n          // 2. User activated the \"persist state accross reloads\" option\n          //    and now the state is imported during reload.\n          // Because of option 2, we need to give possible\n          // lazy loaded reducers time to instantiate.\n          // As soon as there is no UPDATE action within 1 second,\n          // it is assumed that all reducers are loaded.\n          return _this3.dispatcher.pipe(filter(\n          /**\n          * @param {?} action\n          * @return {?}\n          */\n          function (action) {\n            return action.type === UPDATE;\n          }), timeout(1000), debounceTime(1000), map(\n          /**\n          * @return {?}\n          */\n          function () {\n            return action;\n          }), catchError(\n          /**\n          * @return {?}\n          */\n          function () {\n            return of(action);\n          }), take(1));\n        } else {\n          return of(action);\n        }\n      })); // Listen for unlifted actions\n\n      /** @type {?} */\n\n      var actions$ = changes$.pipe(filter(\n      /**\n      * @param {?} change\n      * @return {?}\n      */\n      function (change) {\n        return change.type === ExtensionActionTypes.ACTION;\n      }), map(\n      /**\n      * @param {?} change\n      * @return {?}\n      */\n      function (change) {\n        return _this3.unwrapAction(change.payload);\n      }));\n      /** @type {?} */\n\n      var actionsUntilStop$ = actions$.pipe(takeUntil(stop$));\n      /** @type {?} */\n\n      var liftedUntilStop$ = liftedActions$.pipe(takeUntil(stop$));\n      this.start$ = start$.pipe(takeUntil(stop$)); // Only take the action sources between the start/stop events\n\n      this.actions$ = this.start$.pipe(switchMap(\n      /**\n      * @return {?}\n      */\n      function () {\n        return actionsUntilStop$;\n      }));\n      this.liftedActions$ = this.start$.pipe(switchMap(\n      /**\n      * @return {?}\n      */\n      function () {\n        return liftedUntilStop$;\n      }));\n    }\n    /**\n     * @private\n     * @param {?} action\n     * @return {?}\n     */\n\n  }, {\n    key: \"unwrapAction\",\n    value: function unwrapAction(action) {\n      return typeof action === 'string' ? eval(\"(\".concat(action, \")\")) : action;\n    }\n    /**\n     * @private\n     * @param {?} config\n     * @return {?}\n     */\n\n  }, {\n    key: \"getExtensionConfig\",\n    value: function getExtensionConfig(config) {\n      /** @type {?} */\n      var extensionOptions = {\n        name: config.name,\n        features: config.features,\n        serialize: config.serialize\n      };\n\n      if (config.maxAge !== false\n      /* support === 0 */\n      ) {\n        extensionOptions.maxAge = config.maxAge;\n      }\n\n      return extensionOptions;\n    }\n    /**\n     * @private\n     * @param {?} send\n     * @return {?}\n     */\n\n  }, {\n    key: \"sendToReduxDevtools\",\n    value: function sendToReduxDevtools(send) {\n      try {\n        send();\n      } catch (err) {\n        console.warn('@ngrx/store-devtools: something went wrong inside the redux devtools', err);\n      }\n    }\n  }]);\n\n  return DevtoolsExtension;\n}();\n\nDevtoolsExtension.decorators = [{\n  type: Injectable\n}];\n/** @nocollapse */\n\nDevtoolsExtension.ctorParameters = function () {\n  return [{\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [REDUX_DEVTOOLS_EXTENSION]\n    }]\n  }, {\n    type: StoreDevtoolsConfig,\n    decorators: [{\n      type: Inject,\n      args: [STORE_DEVTOOLS_CONFIG]\n    }]\n  }, {\n    type: DevtoolsDispatcher\n  }];\n};\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  DevtoolsExtension.prototype.devtoolsExtension;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DevtoolsExtension.prototype.extensionConnection;\n  /** @type {?} */\n\n  DevtoolsExtension.prototype.liftedActions$;\n  /** @type {?} */\n\n  DevtoolsExtension.prototype.actions$;\n  /** @type {?} */\n\n  DevtoolsExtension.prototype.start$;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DevtoolsExtension.prototype.config;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  DevtoolsExtension.prototype.dispatcher;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/reducer.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar INIT_ACTION = {\n  type: INIT\n};\n/** @type {?} */\n\nvar RECOMPUTE =\n/** @type {?} */\n'@ngrx/store-devtools/recompute';\n/** @type {?} */\n\nvar RECOMPUTE_ACTION = {\n  type: RECOMPUTE\n};\n/**\n * @record\n */\n\nfunction ComputedState() {}\n\nif (false) {\n  /** @type {?} */\n  ComputedState.prototype.state;\n  /** @type {?} */\n\n  ComputedState.prototype.error;\n}\n/**\n * @record\n */\n\n\nfunction LiftedAction() {}\n\nif (false) {\n  /** @type {?} */\n  LiftedAction.prototype.type;\n  /** @type {?} */\n\n  LiftedAction.prototype.action;\n}\n/**\n * @record\n */\n\n\nfunction LiftedActions() {}\n/**\n * @record\n */\n\n\nfunction LiftedState() {}\n\nif (false) {\n  /** @type {?} */\n  LiftedState.prototype.monitorState;\n  /** @type {?} */\n\n  LiftedState.prototype.nextActionId;\n  /** @type {?} */\n\n  LiftedState.prototype.actionsById;\n  /** @type {?} */\n\n  LiftedState.prototype.stagedActionIds;\n  /** @type {?} */\n\n  LiftedState.prototype.skippedActionIds;\n  /** @type {?} */\n\n  LiftedState.prototype.committedState;\n  /** @type {?} */\n\n  LiftedState.prototype.currentStateIndex;\n  /** @type {?} */\n\n  LiftedState.prototype.computedStates;\n  /** @type {?} */\n\n  LiftedState.prototype.isLocked;\n  /** @type {?} */\n\n  LiftedState.prototype.isPaused;\n}\n/**\n * Computes the next entry in the log by applying an action.\n * @param {?} reducer\n * @param {?} action\n * @param {?} state\n * @param {?} error\n * @param {?} errorHandler\n * @return {?}\n */\n\n\nfunction computeNextEntry(reducer, action, state, error, errorHandler) {\n  if (error) {\n    return {\n      state: state,\n      error: 'Interrupted by an error up the chain'\n    };\n  }\n  /** @type {?} */\n\n\n  var nextState = state;\n  /** @type {?} */\n\n  var nextError;\n\n  try {\n    nextState = reducer(state, action);\n  } catch (err) {\n    nextError = err.toString();\n    errorHandler.handleError(err.stack || err);\n  }\n\n  return {\n    state: nextState,\n    error: nextError\n  };\n}\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n * @param {?} computedStates\n * @param {?} minInvalidatedStateIndex\n * @param {?} reducer\n * @param {?} committedState\n * @param {?} actionsById\n * @param {?} stagedActionIds\n * @param {?} skippedActionIds\n * @param {?} errorHandler\n * @param {?} isPaused\n * @return {?}\n */\n\n\nfunction recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (minInvalidatedStateIndex >= computedStates.length && computedStates.length === stagedActionIds.length) {\n    return computedStates;\n  }\n  /** @type {?} */\n\n\n  var nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex); // If the recording is paused, recompute all states up until the pause state,\n  // else recompute all states.\n\n  /** @type {?} */\n\n  var lastIncludedActionId = stagedActionIds.length - (isPaused ? 1 : 0);\n\n  for (var i = minInvalidatedStateIndex; i < lastIncludedActionId; i++) {\n    /** @type {?} */\n    var actionId = stagedActionIds[i];\n    /** @type {?} */\n\n    var action = actionsById[actionId].action;\n    /** @type {?} */\n\n    var previousEntry = nextComputedStates[i - 1];\n    /** @type {?} */\n\n    var previousState = previousEntry ? previousEntry.state : committedState;\n    /** @type {?} */\n\n    var previousError = previousEntry ? previousEntry.error : undefined;\n    /** @type {?} */\n\n    var shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n    /** @type {?} */\n\n    var entry = shouldSkip ? previousEntry : computeNextEntry(reducer, action, previousState, previousError, errorHandler);\n    nextComputedStates.push(entry);\n  } // If the recording is paused, the last state will not be recomputed,\n  // because it's essentially not part of the state history.\n\n\n  if (isPaused) {\n    nextComputedStates.push(computedStates[computedStates.length - 1]);\n  }\n\n  return nextComputedStates;\n}\n/**\n * @param {?=} initialCommittedState\n * @param {?=} monitorReducer\n * @return {?}\n */\n\n\nfunction liftInitialState(initialCommittedState, monitorReducer) {\n  return {\n    monitorState: monitorReducer(undefined, {}),\n    nextActionId: 1,\n    actionsById: {\n      0: liftAction(INIT_ACTION)\n    },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState,\n    currentStateIndex: 0,\n    computedStates: [],\n    isLocked: false,\n    isPaused: false\n  };\n}\n/**\n * Creates a history state reducer from an app's reducer.\n * @param {?} initialCommittedState\n * @param {?} initialLiftedState\n * @param {?} errorHandler\n * @param {?=} monitorReducer\n * @param {?=} options\n * @return {?}\n */\n\n\nfunction liftReducerWith(initialCommittedState, initialLiftedState, errorHandler, monitorReducer) {\n  var options = arguments.length > 4 && arguments[4] !== undefined ? arguments[4] : {};\n\n  /**\n   * Manages how the history actions modify the history state.\n   */\n  return (\n    /**\n    * @param {?} reducer\n    * @return {?}\n    */\n    function (reducer) {\n      return (\n        /**\n        * @param {?} liftedState\n        * @param {?} liftedAction\n        * @return {?}\n        */\n        function (liftedState, liftedAction) {\n          var _ref = liftedState || initialLiftedState,\n              monitorState = _ref.monitorState,\n              actionsById = _ref.actionsById,\n              nextActionId = _ref.nextActionId,\n              stagedActionIds = _ref.stagedActionIds,\n              skippedActionIds = _ref.skippedActionIds,\n              committedState = _ref.committedState,\n              currentStateIndex = _ref.currentStateIndex,\n              computedStates = _ref.computedStates,\n              isLocked = _ref.isLocked,\n              isPaused = _ref.isPaused;\n\n          if (!liftedState) {\n            // Prevent mutating initialLiftedState\n            actionsById = Object.create(actionsById);\n          }\n          /**\n           * @param {?} n\n           * @return {?}\n           */\n\n\n          function commitExcessActions(n) {\n            // Auto-commits n-number of excess actions.\n\n            /** @type {?} */\n            var excess = n;\n            /** @type {?} */\n\n            var idsToDelete = stagedActionIds.slice(1, excess + 1);\n\n            for (var i = 0; i < idsToDelete.length; i++) {\n              if (computedStates[i + 1].error) {\n                // Stop if error is found. Commit actions up to error.\n                excess = i;\n                idsToDelete = stagedActionIds.slice(1, excess + 1);\n                break;\n              } else {\n                delete actionsById[idsToDelete[i]];\n              }\n            }\n\n            skippedActionIds = skippedActionIds.filter(\n            /**\n            * @param {?} id\n            * @return {?}\n            */\n            function (id) {\n              return idsToDelete.indexOf(id) === -1;\n            });\n            stagedActionIds = [0].concat(_toConsumableArray(stagedActionIds.slice(excess + 1)));\n            committedState = computedStates[excess].state;\n            computedStates = computedStates.slice(excess);\n            currentStateIndex = currentStateIndex > excess ? currentStateIndex - excess : 0;\n          }\n          /**\n           * @return {?}\n           */\n\n\n          function commitChanges() {\n            // Consider the last committed state the new starting point.\n            // Squash any staged actions into a single committed state.\n            actionsById = {\n              0: liftAction(INIT_ACTION)\n            };\n            nextActionId = 1;\n            stagedActionIds = [0];\n            skippedActionIds = [];\n            committedState = computedStates[currentStateIndex].state;\n            currentStateIndex = 0;\n            computedStates = [];\n          } // By default, aggressively recompute every state whatever happens.\n          // This has O(n) performance, so we'll override this to a sensible\n          // value whenever we feel like we don't have to recompute the states.\n\n          /** @type {?} */\n\n\n          var minInvalidatedStateIndex = 0;\n\n          switch (liftedAction.type) {\n            case LOCK_CHANGES:\n              {\n                isLocked = liftedAction.status;\n                minInvalidatedStateIndex = Infinity;\n                break;\n              }\n\n            case PAUSE_RECORDING:\n              {\n                isPaused = liftedAction.status;\n\n                if (isPaused) {\n                  // Add a pause action to signal the devtools-user the recording is paused.\n                  // The corresponding state will be overwritten on each update to always contain\n                  // the latest state (see Actions.PERFORM_ACTION).\n                  stagedActionIds = [].concat(_toConsumableArray(stagedActionIds), [nextActionId]);\n                  actionsById[nextActionId] = new PerformAction({\n                    type: '@ngrx/devtools/pause'\n                  }, +Date.now());\n                  nextActionId++;\n                  minInvalidatedStateIndex = stagedActionIds.length - 1;\n                  computedStates = computedStates.concat(computedStates[computedStates.length - 1]);\n\n                  if (currentStateIndex === stagedActionIds.length - 2) {\n                    currentStateIndex++;\n                  }\n\n                  minInvalidatedStateIndex = Infinity;\n                } else {\n                  commitChanges();\n                }\n\n                break;\n              }\n\n            case RESET:\n              {\n                // Get back to the state the store was created with.\n                actionsById = {\n                  0: liftAction(INIT_ACTION)\n                };\n                nextActionId = 1;\n                stagedActionIds = [0];\n                skippedActionIds = [];\n                committedState = initialCommittedState;\n                currentStateIndex = 0;\n                computedStates = [];\n                break;\n              }\n\n            case COMMIT:\n              {\n                commitChanges();\n                break;\n              }\n\n            case ROLLBACK:\n              {\n                // Forget about any staged actions.\n                // Start again from the last committed state.\n                actionsById = {\n                  0: liftAction(INIT_ACTION)\n                };\n                nextActionId = 1;\n                stagedActionIds = [0];\n                skippedActionIds = [];\n                currentStateIndex = 0;\n                computedStates = [];\n                break;\n              }\n\n            case TOGGLE_ACTION:\n              {\n                // Toggle whether an action with given ID is skipped.\n                // Being skipped means it is a no-op during the computation.\n                var actionId = liftedAction.id;\n                /** @type {?} */\n\n                var index = skippedActionIds.indexOf(actionId);\n\n                if (index === -1) {\n                  skippedActionIds = [actionId].concat(_toConsumableArray(skippedActionIds));\n                } else {\n                  skippedActionIds = skippedActionIds.filter(\n                  /**\n                  * @param {?} id\n                  * @return {?}\n                  */\n                  function (id) {\n                    return id !== actionId;\n                  });\n                } // Optimization: we know history before this action hasn't changed\n\n\n                minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);\n                break;\n              }\n\n            case SET_ACTIONS_ACTIVE:\n              {\n                // Toggle whether an action with given ID is skipped.\n                // Being skipped means it is a no-op during the computation.\n                var start = liftedAction.start,\n                    end = liftedAction.end,\n                    active = liftedAction.active;\n                /** @type {?} */\n\n                var actionIds = [];\n\n                for (var i = start; i < end; i++) actionIds.push(i);\n\n                if (active) {\n                  skippedActionIds = difference(skippedActionIds, actionIds);\n                } else {\n                  skippedActionIds = [].concat(_toConsumableArray(skippedActionIds), actionIds);\n                } // Optimization: we know history before this action hasn't changed\n\n\n                minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n                break;\n              }\n\n            case JUMP_TO_STATE:\n              {\n                // Without recomputing anything, move the pointer that tell us\n                // which state is considered the current one. Useful for sliders.\n                currentStateIndex = liftedAction.index; // Optimization: we know the history has not changed.\n\n                minInvalidatedStateIndex = Infinity;\n                break;\n              }\n\n            case JUMP_TO_ACTION:\n              {\n                // Jumps to a corresponding state to a specific action.\n                // Useful when filtering actions.\n\n                /** @type {?} */\n                var _index = stagedActionIds.indexOf(liftedAction.actionId);\n\n                if (_index !== -1) currentStateIndex = _index;\n                minInvalidatedStateIndex = Infinity;\n                break;\n              }\n\n            case SWEEP:\n              {\n                // Forget any actions that are currently being skipped.\n                stagedActionIds = difference(stagedActionIds, skippedActionIds);\n                skippedActionIds = [];\n                currentStateIndex = Math.min(currentStateIndex, stagedActionIds.length - 1);\n                break;\n              }\n\n            case PERFORM_ACTION:\n              {\n                // Ignore action and return state as is if recording is locked\n                if (isLocked) {\n                  return liftedState || initialLiftedState;\n                }\n\n                if (isPaused || liftedState && isActionFiltered(liftedState.computedStates[currentStateIndex], liftedAction, options.predicate, options.actionsSafelist, options.actionsBlocklist)) {\n                  // If recording is paused or if the action should be ignored, overwrite the last state\n                  // (corresponds to the pause action) and keep everything else as is.\n                  // This way, the app gets the new current state while the devtools\n                  // do not record another action.\n\n                  /** @type {?} */\n                  var lastState = computedStates[computedStates.length - 1];\n                  computedStates = [].concat(_toConsumableArray(computedStates.slice(0, -1)), [computeNextEntry(reducer, liftedAction.action, lastState.state, lastState.error, errorHandler)]);\n                  minInvalidatedStateIndex = Infinity;\n                  break;\n                } // Auto-commit as new actions come in.\n\n\n                if (options.maxAge && stagedActionIds.length === options.maxAge) {\n                  commitExcessActions(1);\n                }\n\n                if (currentStateIndex === stagedActionIds.length - 1) {\n                  currentStateIndex++;\n                }\n                /** @type {?} */\n\n\n                var _actionId = nextActionId++; // Mutation! This is the hottest path, and we optimize on purpose.\n                // It is safe because we set a new key in a cache dictionary.\n\n\n                actionsById[_actionId] = liftedAction;\n                stagedActionIds = [].concat(_toConsumableArray(stagedActionIds), [_actionId]); // Optimization: we know that only the new action needs computing.\n\n                minInvalidatedStateIndex = stagedActionIds.length - 1;\n                break;\n              }\n\n            case IMPORT_STATE:\n              {\n                // Completely replace everything.\n                var _liftedAction$nextLif = liftedAction.nextLiftedState;\n                monitorState = _liftedAction$nextLif.monitorState;\n                actionsById = _liftedAction$nextLif.actionsById;\n                nextActionId = _liftedAction$nextLif.nextActionId;\n                stagedActionIds = _liftedAction$nextLif.stagedActionIds;\n                skippedActionIds = _liftedAction$nextLif.skippedActionIds;\n                committedState = _liftedAction$nextLif.committedState;\n                currentStateIndex = _liftedAction$nextLif.currentStateIndex;\n                computedStates = _liftedAction$nextLif.computedStates;\n                isLocked = _liftedAction$nextLif.isLocked;\n                isPaused = _liftedAction$nextLif.isPaused;\n                break;\n              }\n\n            case INIT:\n              {\n                // Always recompute states on hot reload and init.\n                minInvalidatedStateIndex = 0;\n\n                if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                  // States must be recomputed before committing excess.\n                  computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n                  commitExcessActions(stagedActionIds.length - options.maxAge); // Avoid double computation.\n\n                  minInvalidatedStateIndex = Infinity;\n                }\n\n                break;\n              }\n\n            case UPDATE:\n              {\n                /** @type {?} */\n                var stateHasErrors = computedStates.filter(\n                /**\n                * @param {?} state\n                * @return {?}\n                */\n                function (state) {\n                  return state.error;\n                }).length > 0;\n\n                if (stateHasErrors) {\n                  // Recompute all states\n                  minInvalidatedStateIndex = 0;\n\n                  if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                    // States must be recomputed before committing excess.\n                    computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n                    commitExcessActions(stagedActionIds.length - options.maxAge); // Avoid double computation.\n\n                    minInvalidatedStateIndex = Infinity;\n                  }\n                } else {\n                  // If not paused/locked, add a new action to signal devtools-user\n                  // that there was a reducer update.\n                  if (!isPaused && !isLocked) {\n                    if (currentStateIndex === stagedActionIds.length - 1) {\n                      currentStateIndex++;\n                    } // Add a new action to only recompute state\n\n                    /** @type {?} */\n\n\n                    var _actionId2 = nextActionId++;\n\n                    actionsById[_actionId2] = new PerformAction(liftedAction, +Date.now());\n                    stagedActionIds = [].concat(_toConsumableArray(stagedActionIds), [_actionId2]);\n                    minInvalidatedStateIndex = stagedActionIds.length - 1;\n                    computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n                  } // Recompute state history with latest reducer and update action\n\n\n                  computedStates = computedStates.map(\n                  /**\n                  * @param {?} cmp\n                  * @return {?}\n                  */\n                  function (cmp) {\n                    return Object.assign(Object.assign({}, cmp), {\n                      state: reducer(cmp.state, RECOMPUTE_ACTION)\n                    });\n                  });\n                  currentStateIndex = stagedActionIds.length - 1;\n\n                  if (options.maxAge && stagedActionIds.length > options.maxAge) {\n                    commitExcessActions(stagedActionIds.length - options.maxAge);\n                  } // Avoid double computation.\n\n\n                  minInvalidatedStateIndex = Infinity;\n                }\n\n                break;\n              }\n\n            default:\n              {\n                // If the action is not recognized, it's a monitor action.\n                // Optimization: a monitor action can't change history.\n                minInvalidatedStateIndex = Infinity;\n                break;\n              }\n          }\n\n          computedStates = recomputeStates(computedStates, minInvalidatedStateIndex, reducer, committedState, actionsById, stagedActionIds, skippedActionIds, errorHandler, isPaused);\n          monitorState = monitorReducer(monitorState, liftedAction);\n          return {\n            monitorState: monitorState,\n            actionsById: actionsById,\n            nextActionId: nextActionId,\n            stagedActionIds: stagedActionIds,\n            skippedActionIds: skippedActionIds,\n            committedState: committedState,\n            currentStateIndex: currentStateIndex,\n            computedStates: computedStates,\n            isLocked: isLocked,\n            isPaused: isPaused\n          };\n        }\n      );\n    }\n  );\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/devtools.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n\nvar StoreDevtools = /*#__PURE__*/function () {\n  /**\n   * @param {?} dispatcher\n   * @param {?} actions$\n   * @param {?} reducers$\n   * @param {?} extension\n   * @param {?} scannedActions\n   * @param {?} errorHandler\n   * @param {?} initialState\n   * @param {?} config\n   */\n  function StoreDevtools(dispatcher, actions$, reducers$, extension, scannedActions, errorHandler, initialState, config) {\n    var _this4 = this;\n\n    _classCallCheck(this, StoreDevtools);\n\n    /** @type {?} */\n    var liftedInitialState = liftInitialState(initialState, config.monitor);\n    /** @type {?} */\n\n    var liftReducer = liftReducerWith(initialState, liftedInitialState, errorHandler, config.monitor, config);\n    /** @type {?} */\n\n    var liftedAction$ = merge(merge(actions$.asObservable().pipe(skip(1)), extension.actions$).pipe(map(liftAction)), dispatcher, extension.liftedActions$).pipe(observeOn(queueScheduler));\n    /** @type {?} */\n\n    var liftedReducer$ = reducers$.pipe(map(liftReducer));\n    /** @type {?} */\n\n    var liftedStateSubject = new ReplaySubject(1);\n    /** @type {?} */\n\n    var liftedStateSubscription = liftedAction$.pipe(withLatestFrom(liftedReducer$), scan(\n    /**\n    * @param {?} __0\n    * @param {?} __1\n    * @return {?}\n    */\n    function (_ref2, _ref3) {\n      var liftedState = _ref2.state;\n\n      var _ref4 = _slicedToArray(_ref3, 2),\n          action = _ref4[0],\n          reducer = _ref4[1];\n\n      /** @type {?} */\n      var reducedLiftedState = reducer(liftedState, action); // On full state update\n      // If we have actions filters, we must filter completely our lifted state to be sync with the extension\n\n      if (action.type !== PERFORM_ACTION && shouldFilterActions(config)) {\n        reducedLiftedState = filterLiftedState(reducedLiftedState, config.predicate, config.actionsSafelist, config.actionsBlocklist);\n      } // Extension should be sent the sanitized lifted state\n\n\n      extension.notify(action, reducedLiftedState);\n      return {\n        state: reducedLiftedState,\n        action: action\n      };\n    }, {\n      state: liftedInitialState,\n      action:\n      /** @type {?} */\n      null\n    })).subscribe(\n    /**\n    * @param {?} __0\n    * @return {?}\n    */\n    function (_ref5) {\n      var state = _ref5.state,\n          action = _ref5.action;\n      liftedStateSubject.next(state);\n\n      if (action.type === PERFORM_ACTION) {\n        /** @type {?} */\n        var unliftedAction =\n        /** @type {?} */\n        action.action;\n        scannedActions.next(unliftedAction);\n      }\n    });\n    /** @type {?} */\n\n    var extensionStartSubscription = extension.start$.subscribe(\n    /**\n    * @return {?}\n    */\n    function () {\n      _this4.refresh();\n    });\n    /** @type {?} */\n\n    var liftedState$ =\n    /** @type {?} */\n    liftedStateSubject.asObservable();\n    /** @type {?} */\n\n    var state$ = liftedState$.pipe(map(unliftState));\n    this.extensionStartSubscription = extensionStartSubscription;\n    this.stateSubscription = liftedStateSubscription;\n    this.dispatcher = dispatcher;\n    this.liftedState = liftedState$;\n    this.state = state$;\n  }\n  /**\n   * @param {?} action\n   * @return {?}\n   */\n\n\n  _createClass(StoreDevtools, [{\n    key: \"dispatch\",\n    value: function dispatch(action) {\n      this.dispatcher.next(action);\n    }\n    /**\n     * @param {?} action\n     * @return {?}\n     */\n\n  }, {\n    key: \"next\",\n    value: function next(action) {\n      this.dispatcher.next(action);\n    }\n    /**\n     * @param {?} error\n     * @return {?}\n     */\n\n  }, {\n    key: \"error\",\n    value: function error(_error) {}\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"complete\",\n    value: function complete() {}\n    /**\n     * @param {?} action\n     * @return {?}\n     */\n\n  }, {\n    key: \"performAction\",\n    value: function performAction(action) {\n      this.dispatch(new PerformAction(action, +Date.now()));\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"refresh\",\n    value: function refresh() {\n      this.dispatch(new Refresh());\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"reset\",\n    value: function reset() {\n      this.dispatch(new Reset(+Date.now()));\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"rollback\",\n    value: function rollback() {\n      this.dispatch(new Rollback(+Date.now()));\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"commit\",\n    value: function commit() {\n      this.dispatch(new Commit(+Date.now()));\n    }\n    /**\n     * @return {?}\n     */\n\n  }, {\n    key: \"sweep\",\n    value: function sweep() {\n      this.dispatch(new Sweep());\n    }\n    /**\n     * @param {?} id\n     * @return {?}\n     */\n\n  }, {\n    key: \"toggleAction\",\n    value: function toggleAction(id) {\n      this.dispatch(new ToggleAction(id));\n    }\n    /**\n     * @param {?} actionId\n     * @return {?}\n     */\n\n  }, {\n    key: \"jumpToAction\",\n    value: function jumpToAction(actionId) {\n      this.dispatch(new JumpToAction(actionId));\n    }\n    /**\n     * @param {?} index\n     * @return {?}\n     */\n\n  }, {\n    key: \"jumpToState\",\n    value: function jumpToState(index) {\n      this.dispatch(new JumpToState(index));\n    }\n    /**\n     * @param {?} nextLiftedState\n     * @return {?}\n     */\n\n  }, {\n    key: \"importState\",\n    value: function importState(nextLiftedState) {\n      this.dispatch(new ImportState(nextLiftedState));\n    }\n    /**\n     * @param {?} status\n     * @return {?}\n     */\n\n  }, {\n    key: \"lockChanges\",\n    value: function lockChanges(status) {\n      this.dispatch(new LockChanges(status));\n    }\n    /**\n     * @param {?} status\n     * @return {?}\n     */\n\n  }, {\n    key: \"pauseRecording\",\n    value: function pauseRecording(status) {\n      this.dispatch(new PauseRecording(status));\n    }\n  }]);\n\n  return StoreDevtools;\n}();\n\nStoreDevtools.decorators = [{\n  type: Injectable\n}];\n/** @nocollapse */\n\nStoreDevtools.ctorParameters = function () {\n  return [{\n    type: DevtoolsDispatcher\n  }, {\n    type: ActionsSubject\n  }, {\n    type: ReducerObservable\n  }, {\n    type: DevtoolsExtension\n  }, {\n    type: ScannedActionsSubject\n  }, {\n    type: ErrorHandler\n  }, {\n    type: undefined,\n    decorators: [{\n      type: Inject,\n      args: [INITIAL_STATE]\n    }]\n  }, {\n    type: StoreDevtoolsConfig,\n    decorators: [{\n      type: Inject,\n      args: [STORE_DEVTOOLS_CONFIG]\n    }]\n  }];\n};\n\nif (false) {\n  /**\n   * @type {?}\n   * @private\n   */\n  StoreDevtools.prototype.stateSubscription;\n  /**\n   * @type {?}\n   * @private\n   */\n\n  StoreDevtools.prototype.extensionStartSubscription;\n  /** @type {?} */\n\n  StoreDevtools.prototype.dispatcher;\n  /** @type {?} */\n\n  StoreDevtools.prototype.liftedState;\n  /** @type {?} */\n\n  StoreDevtools.prototype.state;\n}\n/**\n * @fileoverview added by tsickle\n * Generated from: src/instrument.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/** @type {?} */\n\n\nvar IS_EXTENSION_OR_MONITOR_PRESENT = new InjectionToken('Is Devtools Extension or Monitor Present');\n/**\n * @param {?} extension\n * @param {?} config\n * @return {?}\n */\n\nfunction createIsExtensionOrMonitorPresent(extension, config) {\n  return Boolean(extension) || config.monitor !== noMonitor;\n}\n/**\n * @return {?}\n */\n\n\nfunction createReduxDevtoolsExtension() {\n  /** @type {?} */\n  var extensionKey = '__REDUX_DEVTOOLS_EXTENSION__';\n\n  if (typeof window === 'object' && typeof\n  /** @type {?} */\n  window[extensionKey] !== 'undefined') {\n    return (\n      /** @type {?} */\n      window[extensionKey]\n    );\n  } else {\n    return null;\n  }\n}\n/**\n * @param {?} devtools\n * @return {?}\n */\n\n\nfunction createStateObservable(devtools) {\n  return devtools.state;\n}\n\nvar StoreDevtoolsModule = /*#__PURE__*/function () {\n  function StoreDevtoolsModule() {\n    _classCallCheck(this, StoreDevtoolsModule);\n  }\n\n  _createClass(StoreDevtoolsModule, null, [{\n    key: \"instrument\",\n    value:\n    /**\n     * @param {?=} options\n     * @return {?}\n     */\n    function instrument() {\n      var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n      return {\n        ngModule: StoreDevtoolsModule,\n        providers: [DevtoolsExtension, DevtoolsDispatcher, StoreDevtools, {\n          provide: INITIAL_OPTIONS,\n          useValue: options\n        }, {\n          provide: IS_EXTENSION_OR_MONITOR_PRESENT,\n          deps: [REDUX_DEVTOOLS_EXTENSION, STORE_DEVTOOLS_CONFIG],\n          useFactory: createIsExtensionOrMonitorPresent\n        }, {\n          provide: REDUX_DEVTOOLS_EXTENSION,\n          useFactory: createReduxDevtoolsExtension\n        }, {\n          provide: STORE_DEVTOOLS_CONFIG,\n          deps: [INITIAL_OPTIONS],\n          useFactory: createConfig\n        }, {\n          provide: StateObservable,\n          deps: [StoreDevtools],\n          useFactory: createStateObservable\n        }, {\n          provide: ReducerManagerDispatcher,\n          useExisting: DevtoolsDispatcher\n        }]\n      };\n    }\n  }]);\n\n  return StoreDevtoolsModule;\n}();\n\nStoreDevtoolsModule.decorators = [{\n  type: NgModule,\n  args: [{}]\n}];\n/**\n * @fileoverview added by tsickle\n * Generated from: src/index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: public_api.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: index.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\n/**\n * @fileoverview added by tsickle\n * Generated from: ngrx-store-devtools.ts\n * @suppress {checkTypes,constantProperty,extraRequire,missingOverride,missingReturn,unusedPrivateMembers,uselessCode} checked by tsc\n */\n\nexport { INITIAL_OPTIONS, RECOMPUTE, StoreDevtools, StoreDevtoolsConfig, StoreDevtoolsModule, IS_EXTENSION_OR_MONITOR_PRESENT as a, createIsExtensionOrMonitorPresent as b, createReduxDevtoolsExtension as c, createStateObservable as d, STORE_DEVTOOLS_CONFIG as e, noMonitor as f, createConfig as g, REDUX_DEVTOOLS_EXTENSION as h, DevtoolsExtension as i, DevtoolsDispatcher as j };","map":{"version":3,"sources":["../../../../modules/store-devtools/src/config.ts","../../../../modules/store-devtools/src/actions.ts","../../../../modules/store-devtools/src/devtools-dispatcher.ts","../../../../modules/store-devtools/src/utils.ts","../../../../modules/store-devtools/src/extension.ts","../../../../modules/store-devtools/src/reducer.ts","../../../../modules/store-devtools/src/devtools.ts","../../../../modules/store-devtools/src/instrument.ts"],"names":["Actions.PerformAction","DevtoolsActions.LOCK_CHANGES","DevtoolsActions.PAUSE_RECORDING","DevtoolsActions.RESET","DevtoolsActions.COMMIT","DevtoolsActions.ROLLBACK","DevtoolsActions.TOGGLE_ACTION","DevtoolsActions.SET_ACTIONS_ACTIVE","DevtoolsActions.JUMP_TO_STATE","DevtoolsActions.JUMP_TO_ACTION","DevtoolsActions.SWEEP","DevtoolsActions.PERFORM_ACTION","DevtoolsActions.IMPORT_STATE","Actions.PERFORM_ACTION","Actions.Refresh","Actions.Reset","Actions.Rollback","Actions.Commit","Actions.Sweep","Actions.ToggleAction","Actions.JumpToAction","Actions.JumpToState","Actions.ImportState","Actions.LockChanges","Actions.PauseRecording"],"mappings":"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","sourcesContent":["import { ActionReducer, Action } from '@ngrx/store';\nimport { InjectionToken } from '@angular/core';\n\nexport type ActionSanitizer = (action: Action, id: number) => Action;\nexport type StateSanitizer = (state: any, index: number) => any;\nexport type SerializationOptions = {\n  options?: boolean | any;\n  replacer?: (key: any, value: any) => {};\n  reviver?: (key: any, value: any) => {};\n  immutable?: any;\n  refs?: Array<any>;\n};\nexport type Predicate = (state: any, action: Action) => boolean;\nexport interface DevToolsFeatureOptions {\n  pause?: boolean;\n  lock?: boolean;\n  persist?: boolean;\n  export?: boolean;\n  import?: 'custom' | boolean;\n  jump?: boolean;\n  skip?: boolean;\n  reorder?: boolean;\n  dispatch?: boolean;\n  test?: boolean;\n}\n\nexport class StoreDevtoolsConfig {\n  maxAge: number | false = false;\n  monitor?: ActionReducer<any, any>;\n  actionSanitizer?: ActionSanitizer;\n  stateSanitizer?: StateSanitizer;\n  name?: string;\n  serialize?: boolean | SerializationOptions;\n  logOnly?: boolean;\n  features?: DevToolsFeatureOptions;\n  actionsBlocklist?: string[];\n  actionsSafelist?: string[];\n  predicate?: Predicate;\n}\n\nexport const STORE_DEVTOOLS_CONFIG = new InjectionToken<StoreDevtoolsConfig>(\n  '@ngrx/devtools Options'\n);\nexport const INITIAL_OPTIONS = new InjectionToken<StoreDevtoolsConfig>(\n  '@ngrx/devtools Initial Config'\n);\n\nexport type StoreDevtoolsOptions =\n  | Partial<StoreDevtoolsConfig>\n  | (() => Partial<StoreDevtoolsConfig>);\n\nexport function noMonitor(): null {\n  return null;\n}\n\nexport const DEFAULT_NAME = 'NgRx Store DevTools';\n\nexport function createConfig(\n  _options: StoreDevtoolsOptions\n): StoreDevtoolsConfig {\n  const DEFAULT_OPTIONS: StoreDevtoolsConfig = {\n    maxAge: false,\n    monitor: noMonitor,\n    actionSanitizer: undefined,\n    stateSanitizer: undefined,\n    name: DEFAULT_NAME,\n    serialize: false,\n    logOnly: false,\n    // Add all features explicitly. This prevent buggy behavior for\n    // options like \"lock\" which might otherwise not show up.\n    features: {\n      pause: true, // start/pause recording of dispatched actions\n      lock: true, // lock/unlock dispatching actions and side effects\n      persist: true, // persist states on page reloading\n      export: true, // export history of actions in a file\n      import: 'custom', // import history of actions from a file\n      jump: true, // jump back and forth (time travelling)\n      skip: true, // skip (cancel) actions\n      reorder: true, // drag and drop actions in the history list\n      dispatch: true, // dispatch custom actions or action creators\n      test: true, // generate tests for the selected actions\n    },\n  };\n\n  let options = typeof _options === 'function' ? _options() : _options;\n  const logOnly = options.logOnly\n    ? { pause: true, export: true, test: true }\n    : false;\n  const features = options.features || logOnly || DEFAULT_OPTIONS.features;\n  const config = Object.assign({}, DEFAULT_OPTIONS, { features }, options);\n\n  if (config.maxAge && config.maxAge < 2) {\n    throw new Error(\n      `Devtools 'maxAge' cannot be less than 2, got ${config.maxAge}`\n    );\n  }\n\n  return config;\n}\n","import { Action } from '@ngrx/store';\n\nexport const PERFORM_ACTION = 'PERFORM_ACTION';\nexport const REFRESH = 'REFRESH';\nexport const RESET = 'RESET';\nexport const ROLLBACK = 'ROLLBACK';\nexport const COMMIT = 'COMMIT';\nexport const SWEEP = 'SWEEP';\nexport const TOGGLE_ACTION = 'TOGGLE_ACTION';\nexport const SET_ACTIONS_ACTIVE = 'SET_ACTIONS_ACTIVE';\nexport const JUMP_TO_STATE = 'JUMP_TO_STATE';\nexport const JUMP_TO_ACTION = 'JUMP_TO_ACTION';\nexport const IMPORT_STATE = 'IMPORT_STATE';\nexport const LOCK_CHANGES = 'LOCK_CHANGES';\nexport const PAUSE_RECORDING = 'PAUSE_RECORDING';\n\nexport class PerformAction implements Action {\n  readonly type = PERFORM_ACTION;\n\n  constructor(public action: Action, public timestamp: number) {\n    if (typeof action.type === 'undefined') {\n      throw new Error(\n        'Actions may not have an undefined \"type\" property. ' +\n          'Have you misspelled a constant?'\n      );\n    }\n  }\n}\n\nexport class Refresh implements Action {\n  readonly type = REFRESH;\n}\n\nexport class Reset implements Action {\n  readonly type = RESET;\n\n  constructor(public timestamp: number) {}\n}\n\nexport class Rollback implements Action {\n  readonly type = ROLLBACK;\n\n  constructor(public timestamp: number) {}\n}\n\nexport class Commit implements Action {\n  readonly type = COMMIT;\n\n  constructor(public timestamp: number) {}\n}\n\nexport class Sweep implements Action {\n  readonly type = SWEEP;\n}\n\nexport class ToggleAction implements Action {\n  readonly type = TOGGLE_ACTION;\n\n  constructor(public id: number) {}\n}\n\nexport class SetActionsActive implements Action {\n  readonly type = SET_ACTIONS_ACTIVE;\n\n  constructor(\n    public start: number,\n    public end: number,\n    public active: boolean = true\n  ) {}\n}\n\nexport class JumpToState implements Action {\n  readonly type = JUMP_TO_STATE;\n\n  constructor(public index: number) {}\n}\n\nexport class JumpToAction implements Action {\n  readonly type = JUMP_TO_ACTION;\n\n  constructor(public actionId: number) {}\n}\n\nexport class ImportState implements Action {\n  readonly type = IMPORT_STATE;\n\n  constructor(public nextLiftedState: any) {}\n}\n\nexport class LockChanges implements Action {\n  readonly type = LOCK_CHANGES;\n\n  constructor(public status: boolean) {}\n}\n\nexport class PauseRecording implements Action {\n  readonly type = PAUSE_RECORDING;\n\n  constructor(public status: boolean) {}\n}\n\nexport type All =\n  | PerformAction\n  | Refresh\n  | Reset\n  | Rollback\n  | Commit\n  | Sweep\n  | ToggleAction\n  | SetActionsActive\n  | JumpToState\n  | JumpToAction\n  | ImportState\n  | LockChanges\n  | PauseRecording;\n","import { ActionsSubject } from '@ngrx/store';\nimport { Injectable } from '@angular/core';\n\n@Injectable()\nexport class DevtoolsDispatcher extends ActionsSubject {}\n","import { Action } from '@ngrx/store';\n\nimport * as Actions from './actions';\nimport {\n  ActionSanitizer,\n  StateSanitizer,\n  Predicate,\n  StoreDevtoolsConfig,\n} from './config';\nimport {\n  ComputedState,\n  LiftedAction,\n  LiftedActions,\n  LiftedState,\n} from './reducer';\n\nexport function difference(first: any[], second: any[]) {\n  return first.filter((item) => second.indexOf(item) < 0);\n}\n\n/**\n * Provides an app's view into the state of the lifted store.\n */\nexport function unliftState(liftedState: LiftedState) {\n  const { computedStates, currentStateIndex } = liftedState;\n\n  // At start up NgRx dispatches init actions,\n  // When these init actions are being filtered out by the predicate or safe/block list options\n  // we don't have a complete computed states yet.\n  // At this point it could happen that we're out of bounds, when this happens we fall back to the last known state\n  if (currentStateIndex >= computedStates.length) {\n    const { state } = computedStates[computedStates.length - 1];\n    return state;\n  }\n\n  const { state } = computedStates[currentStateIndex];\n  return state;\n}\n\nexport function unliftAction(liftedState: LiftedState): LiftedAction {\n  return liftedState.actionsById[liftedState.nextActionId - 1];\n}\n\n/**\n * Lifts an app's action into an action on the lifted store.\n */\nexport function liftAction(action: Action) {\n  return new Actions.PerformAction(action, +Date.now());\n}\n\n/**\n * Sanitizes given actions with given function.\n */\nexport function sanitizeActions(\n  actionSanitizer: ActionSanitizer,\n  actions: LiftedActions\n): LiftedActions {\n  return Object.keys(actions).reduce((sanitizedActions, actionIdx) => {\n    const idx = Number(actionIdx);\n    sanitizedActions[idx] = sanitizeAction(actionSanitizer, actions[idx], idx);\n    return sanitizedActions;\n  }, <LiftedActions>{});\n}\n\n/**\n * Sanitizes given action with given function.\n */\nexport function sanitizeAction(\n  actionSanitizer: ActionSanitizer,\n  action: LiftedAction,\n  actionIdx: number\n): LiftedAction {\n  return {\n    ...action,\n    action: actionSanitizer(action.action, actionIdx),\n  };\n}\n\n/**\n * Sanitizes given states with given function.\n */\nexport function sanitizeStates(\n  stateSanitizer: StateSanitizer,\n  states: ComputedState[]\n): ComputedState[] {\n  return states.map((computedState, idx) => ({\n    state: sanitizeState(stateSanitizer, computedState.state, idx),\n    error: computedState.error,\n  }));\n}\n\n/**\n * Sanitizes given state with given function.\n */\nexport function sanitizeState(\n  stateSanitizer: StateSanitizer,\n  state: any,\n  stateIdx: number\n) {\n  return stateSanitizer(state, stateIdx);\n}\n\n/**\n * Read the config and tell if actions should be filtered\n */\nexport function shouldFilterActions(config: StoreDevtoolsConfig) {\n  return config.predicate || config.actionsSafelist || config.actionsBlocklist;\n}\n\n/**\n * Return a full filtered lifted state\n */\nexport function filterLiftedState(\n  liftedState: LiftedState,\n  predicate?: Predicate,\n  safelist?: string[],\n  blocklist?: string[]\n): LiftedState {\n  const filteredStagedActionIds: number[] = [];\n  const filteredActionsById: LiftedActions = {};\n  const filteredComputedStates: ComputedState[] = [];\n  liftedState.stagedActionIds.forEach((id, idx) => {\n    const liftedAction = liftedState.actionsById[id];\n    if (!liftedAction) return;\n    if (\n      idx &&\n      isActionFiltered(\n        liftedState.computedStates[idx],\n        liftedAction,\n        predicate,\n        safelist,\n        blocklist\n      )\n    ) {\n      return;\n    }\n    filteredActionsById[id] = liftedAction;\n    filteredStagedActionIds.push(id);\n    filteredComputedStates.push(liftedState.computedStates[idx]);\n  });\n  return {\n    ...liftedState,\n    stagedActionIds: filteredStagedActionIds,\n    actionsById: filteredActionsById,\n    computedStates: filteredComputedStates,\n  };\n}\n\n/**\n * Return true is the action should be ignored\n */\nexport function isActionFiltered(\n  state: any,\n  action: LiftedAction,\n  predicate?: Predicate,\n  safelist?: string[],\n  blockedlist?: string[]\n) {\n  const predicateMatch = predicate && !predicate(state, action.action);\n  const safelistMatch =\n    safelist &&\n    !action.action.type.match(safelist.map((s) => escapeRegExp(s)).join('|'));\n  const blocklistMatch =\n    blockedlist &&\n    action.action.type.match(blockedlist.map((s) => escapeRegExp(s)).join('|'));\n  return predicateMatch || safelistMatch || blocklistMatch;\n}\n\n/**\n * Return string with escaped RegExp special characters\n * https://stackoverflow.com/a/6969486/1337347\n */\nfunction escapeRegExp(s: string): string {\n  return s.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&');\n}\n","import { Inject, Injectable, InjectionToken } from '@angular/core';\nimport { Action, UPDATE } from '@ngrx/store';\nimport { empty, Observable, of } from 'rxjs';\nimport {\n  catchError,\n  concatMap,\n  debounceTime,\n  filter,\n  map,\n  share,\n  switchMap,\n  take,\n  takeUntil,\n  timeout,\n} from 'rxjs/operators';\n\nimport { IMPORT_STATE, PERFORM_ACTION } from './actions';\nimport {\n  SerializationOptions,\n  STORE_DEVTOOLS_CONFIG,\n  StoreDevtoolsConfig,\n} from './config';\nimport { DevtoolsDispatcher } from './devtools-dispatcher';\nimport { LiftedAction, LiftedState } from './reducer';\nimport {\n  isActionFiltered,\n  sanitizeAction,\n  sanitizeActions,\n  sanitizeState,\n  sanitizeStates,\n  shouldFilterActions,\n  unliftState,\n} from './utils';\n\nexport const ExtensionActionTypes = {\n  START: 'START',\n  DISPATCH: 'DISPATCH',\n  STOP: 'STOP',\n  ACTION: 'ACTION',\n};\n\nexport const REDUX_DEVTOOLS_EXTENSION = new InjectionToken<\n  ReduxDevtoolsExtension\n>('Redux Devtools Extension');\n\nexport interface ReduxDevtoolsExtensionConnection {\n  subscribe(listener: (change: any) => void): void;\n  unsubscribe(): void;\n  send(action: any, state: any): void;\n  init(state?: any): void;\n  error(anyErr: any): void;\n}\nexport interface ReduxDevtoolsExtensionConfig {\n  features?: object | boolean;\n  name: string | undefined;\n  maxAge?: number;\n  serialize?: boolean | SerializationOptions;\n}\n\nexport interface ReduxDevtoolsExtension {\n  connect(\n    options: ReduxDevtoolsExtensionConfig\n  ): ReduxDevtoolsExtensionConnection;\n  send(action: any, state: any, options: ReduxDevtoolsExtensionConfig): void;\n}\n\n@Injectable()\nexport class DevtoolsExtension {\n  private devtoolsExtension: ReduxDevtoolsExtension;\n  private extensionConnection!: ReduxDevtoolsExtensionConnection;\n\n  liftedActions$!: Observable<any>;\n  actions$!: Observable<any>;\n  start$!: Observable<any>;\n\n  constructor(\n    @Inject(REDUX_DEVTOOLS_EXTENSION) devtoolsExtension: ReduxDevtoolsExtension,\n    @Inject(STORE_DEVTOOLS_CONFIG) private config: StoreDevtoolsConfig,\n    private dispatcher: DevtoolsDispatcher\n  ) {\n    this.devtoolsExtension = devtoolsExtension;\n    this.createActionStreams();\n  }\n\n  notify(action: LiftedAction, state: LiftedState) {\n    if (!this.devtoolsExtension) {\n      return;\n    }\n    // Check to see if the action requires a full update of the liftedState.\n    // If it is a simple action generated by the user's app and the recording\n    // is not locked/paused, only send the action and the current state (fast).\n    //\n    // A full liftedState update (slow: serializes the entire liftedState) is\n    // only required when:\n    //   a) redux-devtools-extension fires the @@Init action (ignored by\n    //      @ngrx/store-devtools)\n    //   b) an action is generated by an @ngrx module (e.g. @ngrx/effects/init\n    //      or @ngrx/store/update-reducers)\n    //   c) the state has been recomputed due to time-traveling\n    //   d) any action that is not a PerformAction to err on the side of\n    //      caution.\n    if (action.type === PERFORM_ACTION) {\n      if (state.isLocked || state.isPaused) {\n        return;\n      }\n\n      const currentState = unliftState(state);\n      if (\n        shouldFilterActions(this.config) &&\n        isActionFiltered(\n          currentState,\n          action,\n          this.config.predicate,\n          this.config.actionsSafelist,\n          this.config.actionsBlocklist\n        )\n      ) {\n        return;\n      }\n      const sanitizedState = this.config.stateSanitizer\n        ? sanitizeState(\n            this.config.stateSanitizer,\n            currentState,\n            state.currentStateIndex\n          )\n        : currentState;\n      const sanitizedAction = this.config.actionSanitizer\n        ? sanitizeAction(\n            this.config.actionSanitizer,\n            action,\n            state.nextActionId\n          )\n        : action;\n\n      this.sendToReduxDevtools(() =>\n        this.extensionConnection.send(sanitizedAction, sanitizedState)\n      );\n    } else {\n      // Requires full state update\n      const sanitizedLiftedState = {\n        ...state,\n        stagedActionIds: state.stagedActionIds,\n        actionsById: this.config.actionSanitizer\n          ? sanitizeActions(this.config.actionSanitizer, state.actionsById)\n          : state.actionsById,\n        computedStates: this.config.stateSanitizer\n          ? sanitizeStates(this.config.stateSanitizer, state.computedStates)\n          : state.computedStates,\n      };\n\n      this.sendToReduxDevtools(() =>\n        this.devtoolsExtension.send(\n          null,\n          sanitizedLiftedState,\n          this.getExtensionConfig(this.config)\n        )\n      );\n    }\n  }\n\n  private createChangesObservable(): Observable<any> {\n    if (!this.devtoolsExtension) {\n      return empty();\n    }\n\n    return new Observable((subscriber) => {\n      const connection = this.devtoolsExtension.connect(\n        this.getExtensionConfig(this.config)\n      );\n      this.extensionConnection = connection;\n      connection.init();\n\n      connection.subscribe((change: any) => subscriber.next(change));\n      return connection.unsubscribe;\n    });\n  }\n\n  private createActionStreams() {\n    // Listens to all changes\n    const changes$ = this.createChangesObservable().pipe(share());\n\n    // Listen for the start action\n    const start$ = changes$.pipe(\n      filter((change: any) => change.type === ExtensionActionTypes.START)\n    );\n\n    // Listen for the stop action\n    const stop$ = changes$.pipe(\n      filter((change: any) => change.type === ExtensionActionTypes.STOP)\n    );\n\n    // Listen for lifted actions\n    const liftedActions$ = changes$.pipe(\n      filter((change) => change.type === ExtensionActionTypes.DISPATCH),\n      map((change) => this.unwrapAction(change.payload)),\n      concatMap((action: any) => {\n        if (action.type === IMPORT_STATE) {\n          // State imports may happen in two situations:\n          // 1. Explicitly by user\n          // 2. User activated the \"persist state accross reloads\" option\n          //    and now the state is imported during reload.\n          // Because of option 2, we need to give possible\n          // lazy loaded reducers time to instantiate.\n          // As soon as there is no UPDATE action within 1 second,\n          // it is assumed that all reducers are loaded.\n          return this.dispatcher.pipe(\n            filter((action) => action.type === UPDATE),\n            timeout(1000),\n            debounceTime(1000),\n            map(() => action),\n            catchError(() => of(action)),\n            take(1)\n          );\n        } else {\n          return of(action);\n        }\n      })\n    );\n\n    // Listen for unlifted actions\n    const actions$ = changes$.pipe(\n      filter((change) => change.type === ExtensionActionTypes.ACTION),\n      map((change) => this.unwrapAction(change.payload))\n    );\n\n    const actionsUntilStop$ = actions$.pipe(takeUntil(stop$));\n    const liftedUntilStop$ = liftedActions$.pipe(takeUntil(stop$));\n    this.start$ = start$.pipe(takeUntil(stop$));\n\n    // Only take the action sources between the start/stop events\n    this.actions$ = this.start$.pipe(switchMap(() => actionsUntilStop$));\n    this.liftedActions$ = this.start$.pipe(switchMap(() => liftedUntilStop$));\n  }\n\n  private unwrapAction(action: Action) {\n    return typeof action === 'string' ? eval(`(${action})`) : action;\n  }\n\n  private getExtensionConfig(config: StoreDevtoolsConfig) {\n    const extensionOptions: ReduxDevtoolsExtensionConfig = {\n      name: config.name,\n      features: config.features,\n      serialize: config.serialize,\n      // The action/state sanitizers are not added to the config\n      // because sanitation is done in this class already.\n      // It is done before sending it to the devtools extension for consistency:\n      // - If we call extensionConnection.send(...),\n      //   the extension would call the sanitizers.\n      // - If we call devtoolsExtension.send(...) (aka full state update),\n      //   the extension would NOT call the sanitizers, so we have to do it ourselves.\n    };\n    if (config.maxAge !== false /* support === 0 */) {\n      extensionOptions.maxAge = config.maxAge;\n    }\n    return extensionOptions;\n  }\n\n  private sendToReduxDevtools(send: Function) {\n    try {\n      send();\n    } catch (err) {\n      console.warn(\n        '@ngrx/store-devtools: something went wrong inside the redux devtools',\n        err\n      );\n    }\n  }\n}\n","import { ErrorHandler } from '@angular/core';\nimport { Action, ActionReducer, UPDATE, INIT } from '@ngrx/store';\n\nimport { difference, liftAction, isActionFiltered } from './utils';\nimport * as DevtoolsActions from './actions';\nimport { StoreDevtoolsConfig } from './config';\nimport { PerformAction } from './actions';\n\nexport type InitAction = {\n  readonly type: typeof INIT;\n};\n\nexport type UpdateReducerAction = {\n  readonly type: typeof UPDATE;\n};\n\nexport type CoreActions = InitAction | UpdateReducerAction;\nexport type Actions = DevtoolsActions.All | CoreActions;\n\nexport const INIT_ACTION = { type: INIT };\n\nexport const RECOMPUTE = '@ngrx/store-devtools/recompute' as '@ngrx/store-devtools/recompute';\nexport const RECOMPUTE_ACTION = { type: RECOMPUTE };\n\nexport interface ComputedState {\n  state: any;\n  error: any;\n}\n\nexport interface LiftedAction {\n  type: string;\n  action: Action;\n}\n\nexport interface LiftedActions {\n  [id: number]: LiftedAction;\n}\n\nexport interface LiftedState {\n  monitorState: any;\n  nextActionId: number;\n  actionsById: LiftedActions;\n  stagedActionIds: number[];\n  skippedActionIds: number[];\n  committedState: any;\n  currentStateIndex: number;\n  computedStates: ComputedState[];\n  isLocked: boolean;\n  isPaused: boolean;\n}\n\n/**\n * Computes the next entry in the log by applying an action.\n */\nfunction computeNextEntry(\n  reducer: ActionReducer<any, any>,\n  action: Action,\n  state: any,\n  error: any,\n  errorHandler: ErrorHandler\n) {\n  if (error) {\n    return {\n      state,\n      error: 'Interrupted by an error up the chain',\n    };\n  }\n\n  let nextState = state;\n  let nextError;\n  try {\n    nextState = reducer(state, action);\n  } catch (err) {\n    nextError = err.toString();\n    errorHandler.handleError(err.stack || err);\n  }\n\n  return {\n    state: nextState,\n    error: nextError,\n  };\n}\n\n/**\n * Runs the reducer on invalidated actions to get a fresh computation log.\n */\nfunction recomputeStates(\n  computedStates: ComputedState[],\n  minInvalidatedStateIndex: number,\n  reducer: ActionReducer<any, any>,\n  committedState: any,\n  actionsById: LiftedActions,\n  stagedActionIds: number[],\n  skippedActionIds: number[],\n  errorHandler: ErrorHandler,\n  isPaused: boolean\n) {\n  // Optimization: exit early and return the same reference\n  // if we know nothing could have changed.\n  if (\n    minInvalidatedStateIndex >= computedStates.length &&\n    computedStates.length === stagedActionIds.length\n  ) {\n    return computedStates;\n  }\n\n  const nextComputedStates = computedStates.slice(0, minInvalidatedStateIndex);\n  // If the recording is paused, recompute all states up until the pause state,\n  // else recompute all states.\n  const lastIncludedActionId = stagedActionIds.length - (isPaused ? 1 : 0);\n  for (let i = minInvalidatedStateIndex; i < lastIncludedActionId; i++) {\n    const actionId = stagedActionIds[i];\n    const action = actionsById[actionId].action;\n\n    const previousEntry = nextComputedStates[i - 1];\n    const previousState = previousEntry ? previousEntry.state : committedState;\n    const previousError = previousEntry ? previousEntry.error : undefined;\n\n    const shouldSkip = skippedActionIds.indexOf(actionId) > -1;\n    const entry: ComputedState = shouldSkip\n      ? previousEntry\n      : computeNextEntry(\n          reducer,\n          action,\n          previousState,\n          previousError,\n          errorHandler\n        );\n\n    nextComputedStates.push(entry);\n  }\n  // If the recording is paused, the last state will not be recomputed,\n  // because it's essentially not part of the state history.\n  if (isPaused) {\n    nextComputedStates.push(computedStates[computedStates.length - 1]);\n  }\n\n  return nextComputedStates;\n}\n\nexport function liftInitialState(\n  initialCommittedState?: any,\n  monitorReducer?: any\n): LiftedState {\n  return {\n    monitorState: monitorReducer(undefined, {}),\n    nextActionId: 1,\n    actionsById: { 0: liftAction(INIT_ACTION) },\n    stagedActionIds: [0],\n    skippedActionIds: [],\n    committedState: initialCommittedState,\n    currentStateIndex: 0,\n    computedStates: [],\n    isLocked: false,\n    isPaused: false,\n  };\n}\n\n/**\n * Creates a history state reducer from an app's reducer.\n */\nexport function liftReducerWith(\n  initialCommittedState: any,\n  initialLiftedState: LiftedState,\n  errorHandler: ErrorHandler,\n  monitorReducer?: any,\n  options: Partial<StoreDevtoolsConfig> = {}\n) {\n  /**\n   * Manages how the history actions modify the history state.\n   */\n  return (\n    reducer: ActionReducer<any, any>\n  ): ActionReducer<LiftedState, Actions> => (liftedState, liftedAction) => {\n    let {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates,\n      isLocked,\n      isPaused,\n    } = liftedState || initialLiftedState;\n\n    if (!liftedState) {\n      // Prevent mutating initialLiftedState\n      actionsById = Object.create(actionsById);\n    }\n\n    function commitExcessActions(n: number) {\n      // Auto-commits n-number of excess actions.\n      let excess = n;\n      let idsToDelete = stagedActionIds.slice(1, excess + 1);\n\n      for (let i = 0; i < idsToDelete.length; i++) {\n        if (computedStates[i + 1].error) {\n          // Stop if error is found. Commit actions up to error.\n          excess = i;\n          idsToDelete = stagedActionIds.slice(1, excess + 1);\n          break;\n        } else {\n          delete actionsById[idsToDelete[i]];\n        }\n      }\n\n      skippedActionIds = skippedActionIds.filter(\n        (id) => idsToDelete.indexOf(id) === -1\n      );\n      stagedActionIds = [0, ...stagedActionIds.slice(excess + 1)];\n      committedState = computedStates[excess].state;\n      computedStates = computedStates.slice(excess);\n      currentStateIndex =\n        currentStateIndex > excess ? currentStateIndex - excess : 0;\n    }\n\n    function commitChanges() {\n      // Consider the last committed state the new starting point.\n      // Squash any staged actions into a single committed state.\n      actionsById = { 0: liftAction(INIT_ACTION) };\n      nextActionId = 1;\n      stagedActionIds = [0];\n      skippedActionIds = [];\n      committedState = computedStates[currentStateIndex].state;\n      currentStateIndex = 0;\n      computedStates = [];\n    }\n\n    // By default, aggressively recompute every state whatever happens.\n    // This has O(n) performance, so we'll override this to a sensible\n    // value whenever we feel like we don't have to recompute the states.\n    let minInvalidatedStateIndex = 0;\n\n    switch (liftedAction.type) {\n      case DevtoolsActions.LOCK_CHANGES: {\n        isLocked = liftedAction.status;\n        minInvalidatedStateIndex = Infinity;\n        break;\n      }\n      case DevtoolsActions.PAUSE_RECORDING: {\n        isPaused = liftedAction.status;\n        if (isPaused) {\n          // Add a pause action to signal the devtools-user the recording is paused.\n          // The corresponding state will be overwritten on each update to always contain\n          // the latest state (see Actions.PERFORM_ACTION).\n          stagedActionIds = [...stagedActionIds, nextActionId];\n          actionsById[nextActionId] = new PerformAction(\n            {\n              type: '@ngrx/devtools/pause',\n            },\n            +Date.now()\n          );\n          nextActionId++;\n          minInvalidatedStateIndex = stagedActionIds.length - 1;\n          computedStates = computedStates.concat(\n            computedStates[computedStates.length - 1]\n          );\n\n          if (currentStateIndex === stagedActionIds.length - 2) {\n            currentStateIndex++;\n          }\n          minInvalidatedStateIndex = Infinity;\n        } else {\n          commitChanges();\n        }\n        break;\n      }\n      case DevtoolsActions.RESET: {\n        // Get back to the state the store was created with.\n        actionsById = { 0: liftAction(INIT_ACTION) };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        committedState = initialCommittedState;\n        currentStateIndex = 0;\n        computedStates = [];\n        break;\n      }\n      case DevtoolsActions.COMMIT: {\n        commitChanges();\n        break;\n      }\n      case DevtoolsActions.ROLLBACK: {\n        // Forget about any staged actions.\n        // Start again from the last committed state.\n        actionsById = { 0: liftAction(INIT_ACTION) };\n        nextActionId = 1;\n        stagedActionIds = [0];\n        skippedActionIds = [];\n        currentStateIndex = 0;\n        computedStates = [];\n        break;\n      }\n      case DevtoolsActions.TOGGLE_ACTION: {\n        // Toggle whether an action with given ID is skipped.\n        // Being skipped means it is a no-op during the computation.\n        const { id: actionId } = liftedAction;\n        const index = skippedActionIds.indexOf(actionId);\n        if (index === -1) {\n          skippedActionIds = [actionId, ...skippedActionIds];\n        } else {\n          skippedActionIds = skippedActionIds.filter((id) => id !== actionId);\n        }\n        // Optimization: we know history before this action hasn't changed\n        minInvalidatedStateIndex = stagedActionIds.indexOf(actionId);\n        break;\n      }\n      case DevtoolsActions.SET_ACTIONS_ACTIVE: {\n        // Toggle whether an action with given ID is skipped.\n        // Being skipped means it is a no-op during the computation.\n        const { start, end, active } = liftedAction;\n        const actionIds = [];\n        for (let i = start; i < end; i++) actionIds.push(i);\n        if (active) {\n          skippedActionIds = difference(skippedActionIds, actionIds);\n        } else {\n          skippedActionIds = [...skippedActionIds, ...actionIds];\n        }\n\n        // Optimization: we know history before this action hasn't changed\n        minInvalidatedStateIndex = stagedActionIds.indexOf(start);\n        break;\n      }\n      case DevtoolsActions.JUMP_TO_STATE: {\n        // Without recomputing anything, move the pointer that tell us\n        // which state is considered the current one. Useful for sliders.\n        currentStateIndex = liftedAction.index;\n        // Optimization: we know the history has not changed.\n        minInvalidatedStateIndex = Infinity;\n        break;\n      }\n      case DevtoolsActions.JUMP_TO_ACTION: {\n        // Jumps to a corresponding state to a specific action.\n        // Useful when filtering actions.\n        const index = stagedActionIds.indexOf(liftedAction.actionId);\n        if (index !== -1) currentStateIndex = index;\n        minInvalidatedStateIndex = Infinity;\n        break;\n      }\n      case DevtoolsActions.SWEEP: {\n        // Forget any actions that are currently being skipped.\n        stagedActionIds = difference(stagedActionIds, skippedActionIds);\n        skippedActionIds = [];\n        currentStateIndex = Math.min(\n          currentStateIndex,\n          stagedActionIds.length - 1\n        );\n        break;\n      }\n      case DevtoolsActions.PERFORM_ACTION: {\n        // Ignore action and return state as is if recording is locked\n        if (isLocked) {\n          return liftedState || initialLiftedState;\n        }\n\n        if (\n          isPaused ||\n          (liftedState &&\n            isActionFiltered(\n              liftedState.computedStates[currentStateIndex],\n              liftedAction,\n              options.predicate,\n              options.actionsSafelist,\n              options.actionsBlocklist\n            ))\n        ) {\n          // If recording is paused or if the action should be ignored, overwrite the last state\n          // (corresponds to the pause action) and keep everything else as is.\n          // This way, the app gets the new current state while the devtools\n          // do not record another action.\n          const lastState = computedStates[computedStates.length - 1];\n          computedStates = [\n            ...computedStates.slice(0, -1),\n            computeNextEntry(\n              reducer,\n              liftedAction.action,\n              lastState.state,\n              lastState.error,\n              errorHandler\n            ),\n          ];\n          minInvalidatedStateIndex = Infinity;\n          break;\n        }\n\n        // Auto-commit as new actions come in.\n        if (options.maxAge && stagedActionIds.length === options.maxAge) {\n          commitExcessActions(1);\n        }\n\n        if (currentStateIndex === stagedActionIds.length - 1) {\n          currentStateIndex++;\n        }\n        const actionId = nextActionId++;\n        // Mutation! This is the hottest path, and we optimize on purpose.\n        // It is safe because we set a new key in a cache dictionary.\n        actionsById[actionId] = liftedAction;\n\n        stagedActionIds = [...stagedActionIds, actionId];\n        // Optimization: we know that only the new action needs computing.\n        minInvalidatedStateIndex = stagedActionIds.length - 1;\n        break;\n      }\n      case DevtoolsActions.IMPORT_STATE: {\n        // Completely replace everything.\n        ({\n          monitorState,\n          actionsById,\n          nextActionId,\n          stagedActionIds,\n          skippedActionIds,\n          committedState,\n          currentStateIndex,\n          computedStates,\n          isLocked,\n          // prettier-ignore\n          isPaused\n        } = liftedAction.nextLiftedState);\n        break;\n      }\n      case INIT: {\n        // Always recompute states on hot reload and init.\n        minInvalidatedStateIndex = 0;\n\n        if (options.maxAge && stagedActionIds.length > options.maxAge) {\n          // States must be recomputed before committing excess.\n          computedStates = recomputeStates(\n            computedStates,\n            minInvalidatedStateIndex,\n            reducer,\n            committedState,\n            actionsById,\n            stagedActionIds,\n            skippedActionIds,\n            errorHandler,\n            isPaused\n          );\n\n          commitExcessActions(stagedActionIds.length - options.maxAge);\n\n          // Avoid double computation.\n          minInvalidatedStateIndex = Infinity;\n        }\n\n        break;\n      }\n      case UPDATE: {\n        const stateHasErrors =\n          computedStates.filter((state) => state.error).length > 0;\n\n        if (stateHasErrors) {\n          // Recompute all states\n          minInvalidatedStateIndex = 0;\n\n          if (options.maxAge && stagedActionIds.length > options.maxAge) {\n            // States must be recomputed before committing excess.\n            computedStates = recomputeStates(\n              computedStates,\n              minInvalidatedStateIndex,\n              reducer,\n              committedState,\n              actionsById,\n              stagedActionIds,\n              skippedActionIds,\n              errorHandler,\n              isPaused\n            );\n\n            commitExcessActions(stagedActionIds.length - options.maxAge);\n\n            // Avoid double computation.\n            minInvalidatedStateIndex = Infinity;\n          }\n        } else {\n          // If not paused/locked, add a new action to signal devtools-user\n          // that there was a reducer update.\n          if (!isPaused && !isLocked) {\n            if (currentStateIndex === stagedActionIds.length - 1) {\n              currentStateIndex++;\n            }\n\n            // Add a new action to only recompute state\n            const actionId = nextActionId++;\n            actionsById[actionId] = new PerformAction(\n              liftedAction,\n              +Date.now()\n            );\n            stagedActionIds = [...stagedActionIds, actionId];\n\n            minInvalidatedStateIndex = stagedActionIds.length - 1;\n\n            computedStates = recomputeStates(\n              computedStates,\n              minInvalidatedStateIndex,\n              reducer,\n              committedState,\n              actionsById,\n              stagedActionIds,\n              skippedActionIds,\n              errorHandler,\n              isPaused\n            );\n          }\n\n          // Recompute state history with latest reducer and update action\n          computedStates = computedStates.map((cmp) => ({\n            ...cmp,\n            state: reducer(cmp.state, RECOMPUTE_ACTION),\n          }));\n\n          currentStateIndex = stagedActionIds.length - 1;\n\n          if (options.maxAge && stagedActionIds.length > options.maxAge) {\n            commitExcessActions(stagedActionIds.length - options.maxAge);\n          }\n\n          // Avoid double computation.\n          minInvalidatedStateIndex = Infinity;\n        }\n\n        break;\n      }\n      default: {\n        // If the action is not recognized, it's a monitor action.\n        // Optimization: a monitor action can't change history.\n        minInvalidatedStateIndex = Infinity;\n        break;\n      }\n    }\n\n    computedStates = recomputeStates(\n      computedStates,\n      minInvalidatedStateIndex,\n      reducer,\n      committedState,\n      actionsById,\n      stagedActionIds,\n      skippedActionIds,\n      errorHandler,\n      isPaused\n    );\n    monitorState = monitorReducer(monitorState, liftedAction);\n\n    return {\n      monitorState,\n      actionsById,\n      nextActionId,\n      stagedActionIds,\n      skippedActionIds,\n      committedState,\n      currentStateIndex,\n      computedStates,\n      isLocked,\n      isPaused,\n    };\n  };\n}\n","import { Injectable, Inject, ErrorHandler } from '@angular/core';\nimport {\n  Action,\n  ActionReducer,\n  ActionsSubject,\n  INITIAL_STATE,\n  ReducerObservable,\n  ScannedActionsSubject,\n} from '@ngrx/store';\nimport {\n  merge,\n  Observable,\n  Observer,\n  queueScheduler,\n  ReplaySubject,\n  Subscription,\n} from 'rxjs';\nimport { map, observeOn, scan, skip, withLatestFrom } from 'rxjs/operators';\n\nimport * as Actions from './actions';\nimport { STORE_DEVTOOLS_CONFIG, StoreDevtoolsConfig } from './config';\nimport { DevtoolsExtension } from './extension';\nimport { LiftedState, liftInitialState, liftReducerWith } from './reducer';\nimport {\n  liftAction,\n  unliftState,\n  shouldFilterActions,\n  filterLiftedState,\n} from './utils';\nimport { DevtoolsDispatcher } from './devtools-dispatcher';\nimport { PERFORM_ACTION } from './actions';\n\n@Injectable()\nexport class StoreDevtools implements Observer<any> {\n  private stateSubscription: Subscription;\n  private extensionStartSubscription: Subscription;\n  public dispatcher: ActionsSubject;\n  public liftedState: Observable<LiftedState>;\n  public state: Observable<any>;\n\n  constructor(\n    dispatcher: DevtoolsDispatcher,\n    actions$: ActionsSubject,\n    reducers$: ReducerObservable,\n    extension: DevtoolsExtension,\n    scannedActions: ScannedActionsSubject,\n    errorHandler: ErrorHandler,\n    @Inject(INITIAL_STATE) initialState: any,\n    @Inject(STORE_DEVTOOLS_CONFIG) config: StoreDevtoolsConfig\n  ) {\n    const liftedInitialState = liftInitialState(initialState, config.monitor);\n    const liftReducer = liftReducerWith(\n      initialState,\n      liftedInitialState,\n      errorHandler,\n      config.monitor,\n      config\n    );\n\n    const liftedAction$ = merge(\n      merge(actions$.asObservable().pipe(skip(1)), extension.actions$).pipe(\n        map(liftAction)\n      ),\n      dispatcher,\n      extension.liftedActions$\n    ).pipe(observeOn(queueScheduler));\n\n    const liftedReducer$ = reducers$.pipe(map(liftReducer));\n\n    const liftedStateSubject = new ReplaySubject<LiftedState>(1);\n\n    const liftedStateSubscription = liftedAction$\n      .pipe(\n        withLatestFrom(liftedReducer$),\n        scan<\n          [any, ActionReducer<LiftedState, Actions.All>],\n          {\n            state: LiftedState;\n            action: any;\n          }\n        >(\n          ({ state: liftedState }, [action, reducer]) => {\n            let reducedLiftedState = reducer(liftedState, action);\n            // On full state update\n            // If we have actions filters, we must filter completely our lifted state to be sync with the extension\n            if (action.type !== PERFORM_ACTION && shouldFilterActions(config)) {\n              reducedLiftedState = filterLiftedState(\n                reducedLiftedState,\n                config.predicate,\n                config.actionsSafelist,\n                config.actionsBlocklist\n              );\n            }\n            // Extension should be sent the sanitized lifted state\n            extension.notify(action, reducedLiftedState);\n            return { state: reducedLiftedState, action };\n          },\n          { state: liftedInitialState, action: null as any }\n        )\n      )\n      .subscribe(({ state, action }) => {\n        liftedStateSubject.next(state);\n\n        if (action.type === Actions.PERFORM_ACTION) {\n          const unliftedAction = (action as Actions.PerformAction).action;\n\n          scannedActions.next(unliftedAction);\n        }\n      });\n\n    const extensionStartSubscription = extension.start$.subscribe(() => {\n      this.refresh();\n    });\n\n    const liftedState$ = liftedStateSubject.asObservable() as Observable<\n      LiftedState\n    >;\n    const state$ = liftedState$.pipe(map(unliftState));\n\n    this.extensionStartSubscription = extensionStartSubscription;\n    this.stateSubscription = liftedStateSubscription;\n    this.dispatcher = dispatcher;\n    this.liftedState = liftedState$;\n    this.state = state$;\n  }\n\n  dispatch(action: Action) {\n    this.dispatcher.next(action);\n  }\n\n  next(action: any) {\n    this.dispatcher.next(action);\n  }\n\n  error(error: any) {}\n\n  complete() {}\n\n  performAction(action: any) {\n    this.dispatch(new Actions.PerformAction(action, +Date.now()));\n  }\n\n  refresh() {\n    this.dispatch(new Actions.Refresh());\n  }\n\n  reset() {\n    this.dispatch(new Actions.Reset(+Date.now()));\n  }\n\n  rollback() {\n    this.dispatch(new Actions.Rollback(+Date.now()));\n  }\n\n  commit() {\n    this.dispatch(new Actions.Commit(+Date.now()));\n  }\n\n  sweep() {\n    this.dispatch(new Actions.Sweep());\n  }\n\n  toggleAction(id: number) {\n    this.dispatch(new Actions.ToggleAction(id));\n  }\n\n  jumpToAction(actionId: number) {\n    this.dispatch(new Actions.JumpToAction(actionId));\n  }\n\n  jumpToState(index: number) {\n    this.dispatch(new Actions.JumpToState(index));\n  }\n\n  importState(nextLiftedState: any) {\n    this.dispatch(new Actions.ImportState(nextLiftedState));\n  }\n\n  lockChanges(status: boolean) {\n    this.dispatch(new Actions.LockChanges(status));\n  }\n\n  pauseRecording(status: boolean) {\n    this.dispatch(new Actions.PauseRecording(status));\n  }\n}\n","import { InjectionToken, ModuleWithProviders, NgModule } from '@angular/core';\nimport { ReducerManagerDispatcher, StateObservable } from '@ngrx/store';\nimport { Observable } from 'rxjs';\n\nimport {\n  INITIAL_OPTIONS,\n  STORE_DEVTOOLS_CONFIG,\n  StoreDevtoolsConfig,\n  StoreDevtoolsOptions,\n  noMonitor,\n  createConfig,\n} from './config';\nimport { StoreDevtools } from './devtools';\nimport {\n  DevtoolsExtension,\n  REDUX_DEVTOOLS_EXTENSION,\n  ReduxDevtoolsExtension,\n} from './extension';\nimport { DevtoolsDispatcher } from './devtools-dispatcher';\n\nexport const IS_EXTENSION_OR_MONITOR_PRESENT = new InjectionToken<boolean>(\n  'Is Devtools Extension or Monitor Present'\n);\n\nexport function createIsExtensionOrMonitorPresent(\n  extension: ReduxDevtoolsExtension | null,\n  config: StoreDevtoolsConfig\n) {\n  return Boolean(extension) || config.monitor !== noMonitor;\n}\n\nexport function createReduxDevtoolsExtension() {\n  const extensionKey = '__REDUX_DEVTOOLS_EXTENSION__';\n\n  if (\n    typeof window === 'object' &&\n    typeof (window as any)[extensionKey] !== 'undefined'\n  ) {\n    return (window as any)[extensionKey];\n  } else {\n    return null;\n  }\n}\n\nexport function createStateObservable(\n  devtools: StoreDevtools\n): Observable<any> {\n  return devtools.state;\n}\n\n@NgModule({})\nexport class StoreDevtoolsModule {\n  static instrument(\n    options: StoreDevtoolsOptions = {}\n  ): ModuleWithProviders<StoreDevtoolsModule> {\n    return {\n      ngModule: StoreDevtoolsModule,\n      providers: [\n        DevtoolsExtension,\n        DevtoolsDispatcher,\n        StoreDevtools,\n        {\n          provide: INITIAL_OPTIONS,\n          useValue: options,\n        },\n        {\n          provide: IS_EXTENSION_OR_MONITOR_PRESENT,\n          deps: [REDUX_DEVTOOLS_EXTENSION, STORE_DEVTOOLS_CONFIG],\n          useFactory: createIsExtensionOrMonitorPresent,\n        },\n        {\n          provide: REDUX_DEVTOOLS_EXTENSION,\n          useFactory: createReduxDevtoolsExtension,\n        },\n        {\n          provide: STORE_DEVTOOLS_CONFIG,\n          deps: [INITIAL_OPTIONS],\n          useFactory: createConfig,\n        },\n        {\n          provide: StateObservable,\n          deps: [StoreDevtools],\n          useFactory: createStateObservable,\n        },\n        {\n          provide: ReducerManagerDispatcher,\n          useExisting: DevtoolsDispatcher,\n        },\n      ],\n    };\n  }\n}\n"]},"metadata":{},"sourceType":"module"}